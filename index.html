<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
      Pathfinder GM Toolkit - Dashboard
      Purpose: Provide a focused dashboard view for core GM tools.
    -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pathfinder GM Toolkit</title>
    <style>
      :root {
        /* Brand palette tuned for Pathfinder dark mode styling. */
        --parchment: #f3e4c3;
        --parchment-dark: #cdb78a;
        --parchment-night: #2a2218;
        --parchment-shadow: #1d170f;
        --ink: #f5ead3;
        --ink-muted: #c7b79a;
        --crimson: #b02a2a;
        --crimson-dark: #7a1414;
        --gold: #c9a24a;
        --gold-bright: #e8c877;
        --shadow: rgba(8, 6, 4, 0.55);
        --success: #6bb36f;
        --warning: #e3a042;
        /* Typography stack */
        --serif: "Georgia", "Times New Roman", serif;
        --sans: "Trebuchet MS", "Segoe UI", sans-serif;
      }

      /* Global reset and base typography */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: var(--sans);
        color: var(--ink);
        background: radial-gradient(circle at top, #3a2f22 0%, var(--parchment-night) 55%, #140f0a 100%);
        line-height: 1.6;
      }

      /* Full-width layout container to use the entire viewport width. */
      .container {
        width: 100%;
        max-width: 100%;
        margin: 0 auto;
        padding: 0 clamp(1.25rem, 3vw, 2.5rem);
      }

      /* Minimal header with only app title, active module, and descriptor. */
      .app-header {
        padding: 1rem 0 0.8rem;
      }

      .header-frame {
        background: rgba(33, 25, 18, 0.95);
        border-radius: 16px;
        padding: 1rem 1.4rem;
        box-shadow: 0 16px 26px var(--shadow);
        border: 1px solid rgba(201, 162, 74, 0.55);
      }

      .header-title {
        font-family: var(--serif);
        font-size: clamp(1.2rem, 2vw, 1.5rem);
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--ink-muted);
      }

      .header-module {
        font-family: var(--serif);
        font-size: clamp(1.6rem, 2.4vw, 2.1rem);
        margin-top: 0.2rem;
      }

      /* Allow header copy to span the full layout width. */
      .header-description {
        margin-top: 0.35rem;
        max-width: 100%;
        color: var(--ink-muted);
      }

      /* Dashboard main grid */
      .dashboard-main {
        padding: 1.1rem 0 2rem;
      }

      .dashboard-grid {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: minmax(0, 2.2fr) minmax(0, 1fr);
      }

      /* Tool grid styles */
      .tool-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }

      /* Section title styling keeps headings compact. */
      .section-title {
        font-family: var(--serif);
        margin-bottom: 0.6rem;
        font-size: 1.2rem;
      }

      .tool-card {
        background: rgba(32, 25, 18, 0.92);
        border-radius: 14px;
        padding: 1rem 1.1rem;
        border-left: 4px solid var(--crimson);
        box-shadow: 0 10px 18px var(--shadow);
      }

      .tool-card--action {
        width: 100%;
        border: none;
        text-align: left;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease;
        padding: 1rem 1.1rem;
        background: rgba(32, 25, 18, 0.92);
        color: inherit;
      }

      .tool-card--action:hover,
      .tool-card--action:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 16px 26px var(--shadow);
        outline: none;
      }

      .tool-card h3 {
        margin-bottom: 0.5rem;
        font-family: var(--serif);
        color: var(--gold-bright);
      }

      .tool-card p {
        margin-bottom: 0.8rem;
      }

      .tool-meta {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        font-size: 0.85rem;
      }

      .tool-tag {
        padding: 0.2rem 0.6rem;
        border-radius: 999px;
        background: rgba(201, 162, 74, 0.2);
        color: var(--ink-muted);
      }

      .tool-launch {
        margin-top: 0.8rem;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        background: transparent;
        color: var(--gold-bright);
        border: 1px dashed rgba(201, 162, 74, 0.7);
      }

      /* Side panels for notes and status */
      .side-panel {
        background: rgba(34, 26, 19, 0.94);
        border-radius: 18px;
        padding: 1.2rem;
        border: 1px dashed rgba(201, 162, 74, 0.6);
        box-shadow: 0 10px 18px var(--shadow);
      }

      .side-panel + .side-panel {
        margin-top: 1.5rem;
      }

      .side-panel h2 {
        font-family: var(--serif);
        margin-bottom: 0.8rem;
      }

      .panel-list {
        list-style: none;
        display: grid;
        gap: 0.75rem;
      }

      .panel-item {
        background: rgba(26, 20, 14, 0.9);
        border-radius: 12px;
        padding: 0.7rem 0.9rem;
        border-left: 4px solid var(--gold);
      }

      /* Initiative tracker layout (compact header to emphasize workspace). */
      .initiative-module {
        padding: 1.1rem 0 2rem;
      }

      /* Compact action row keeps navigation visible without expanding the header. */
      .module-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.8rem;
        margin-bottom: 0.9rem;
      }

      .initiative-tracker {
        margin: 0.9rem 0 0;
        background: rgba(28, 22, 16, 0.92);
        border-radius: 16px;
        padding: 1.1rem;
        border: 1px solid rgba(201, 162, 74, 0.6);
        box-shadow: 0 14px 22px var(--shadow);
      }

      .initiative-tracker h2 {
        font-family: var(--serif);
        margin-bottom: 0.4rem;
      }

      /* Two-panel tracker layout: encounter drawer on the left, tracker on the right. */
      .tracker-layout {
        --drawer-width-expanded: 380px;
        --drawer-width-collapsed: 3.5rem;
        display: grid;
        grid-template-columns: minmax(0, var(--drawer-width-expanded)) minmax(0, 1fr);
        gap: 1.1rem;
        margin-top: 0.8rem;
        align-items: start;
      }

      /* When encounter tools are hidden, allow the tracker to span the full width. */
      .tracker-layout.is-collapsed {
        grid-template-columns: var(--drawer-width-collapsed) minmax(0, 1fr);
      }

      /* Encounter library sidebar gives the GM quick access to saved encounters. */
      .encounter-library {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
      }

      .encounter-list {
        list-style: none;
        display: grid;
        gap: 0.6rem;
      }

      .encounter-entry {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 0.45rem;
        padding: 0.55rem 0.7rem;
        border-radius: 12px;
        background: rgba(20, 16, 12, 0.92);
        border: 1px solid rgba(201, 162, 74, 0.35);
      }

      .encounter-entry.is-active {
        border-color: var(--gold-bright);
        box-shadow: 0 0 0 1px rgba(232, 200, 119, 0.25);
      }

      .encounter-entry-title {
        font-weight: 600;
        color: var(--ink);
      }

      .encounter-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .encounter-action {
        background: transparent;
        border: 1px dashed rgba(201, 162, 74, 0.7);
        color: var(--gold-bright);
        padding: 0.35rem 0.55rem;
        border-radius: 10px;
        cursor: pointer;
        font-size: 0.85rem;
      }

      .encounter-empty {
        color: var(--ink-muted);
        font-size: 0.88rem;
        padding: 0.5rem 0;
      }

      .tracker-panel {
        background: rgba(36, 28, 20, 0.96);
        border-radius: 14px;
        padding: 1rem;
        border: 1px solid rgba(201, 162, 74, 0.35);
      }

      .tracker-panel h3 {
        font-family: var(--serif);
        margin-bottom: 0.8rem;
      }

      /* Support nested panel headings for grouped encounter content. */
      .tracker-panel h4,
      .tracker-panel h5 {
        font-family: var(--serif);
        margin-bottom: 0.6rem;
        color: var(--gold-bright);
      }

      /* Sliding encounter drawer keeps encounter setup and library grouped together. */
      .encounter-drawer {
        position: relative;
        overflow: hidden;
        width: var(--drawer-width-expanded);
        min-height: 100%;
        transition: width 0.35s ease;
      }

      /* Drawer card gives a modal-like shell to connect library and setup content. */
      .encounter-drawer__card {
        background: rgba(42, 32, 24, 0.98);
        border-radius: 18px;
        border: 1px solid rgba(201, 162, 74, 0.6);
        box-shadow: 0 18px 28px var(--shadow);
        overflow: hidden;
        transition: transform 0.35s ease;
      }

      /* Drawer header keeps the label anchored to the container. */
      .encounter-drawer__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.8rem;
        padding: 0.9rem 1rem;
        background: linear-gradient(90deg, rgba(60, 45, 33, 0.95), rgba(38, 29, 21, 0.95));
        border-bottom: 1px solid rgba(201, 162, 74, 0.4);
      }

      .encounter-drawer__header-title {
        font-family: var(--serif);
        font-size: 1rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--gold-bright);
      }

      /* Drawer toggle is integrated into the header for a unified surface. */
      .encounter-drawer__toggle {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 2.4rem;
        height: 2.4rem;
        border-radius: 12px;
        background: rgba(201, 162, 74, 0.18);
        border: 1px solid rgba(201, 162, 74, 0.6);
        color: var(--gold-bright);
        font-weight: 700;
        transition: transform 0.3s ease, box-shadow 0.2s ease;
      }

      .encounter-drawer__toggle:hover,
      .encounter-drawer__toggle:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 10px 18px var(--shadow);
        outline: none;
      }

      .encounter-drawer__toggle-icon {
        display: inline-flex;
        font-size: 1rem;
        transition: transform 0.3s ease;
      }

      .tracker-layout.is-collapsed .encounter-drawer__toggle-icon {
        transform: rotate(180deg);
      }

      /* Drawer body keeps the grouped panels inside the modal-like container. */
      .encounter-drawer__body {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1rem;
        background: rgba(32, 24, 17, 0.92);
      }

      /* Drawer content slides to create a side-tray animation. */
      .encounter-side-panel {
        display: flex;
        flex-direction: column;
        gap: 1.1rem;
        width: var(--drawer-width-expanded);
      }

      /* Collapsed handle preserves a label and control when the drawer is hidden. */
      .encounter-drawer__collapsed-handle {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 0.65rem;
        width: var(--drawer-width-collapsed);
        margin-left: auto;
        background: linear-gradient(180deg, rgba(63, 44, 28, 0.95), rgba(32, 22, 14, 0.95));
        border-left: 1px solid rgba(201, 162, 74, 0.45);
        box-shadow: inset 0 0 18px rgba(0, 0, 0, 0.35);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease;
      }

      .encounter-drawer__collapsed-toggle {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 2.2rem;
        height: 2.2rem;
        border-radius: 12px;
        background: rgba(201, 162, 74, 0.18);
        border: 1px solid rgba(201, 162, 74, 0.6);
        color: var(--gold-bright);
        font-weight: 700;
        transition: transform 0.3s ease, box-shadow 0.2s ease;
      }

      .encounter-drawer__collapsed-toggle:hover,
      .encounter-drawer__collapsed-toggle:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 10px 18px var(--shadow);
        outline: none;
      }

      .encounter-drawer__collapsed-text {
        font-family: var(--serif);
        font-size: 0.85rem;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: var(--gold-bright);
        writing-mode: vertical-rl;
        text-orientation: mixed;
      }

      /* Collapsed state shifts the card out of view while exposing the label. */
      .tracker-layout.is-collapsed .encounter-drawer {
        width: var(--drawer-width-collapsed);
      }

      .tracker-layout.is-collapsed .encounter-drawer__card {
        transform: translateX(calc(-1 * (var(--drawer-width-expanded) - var(--drawer-width-collapsed))));
      }

      .tracker-layout.is-collapsed .encounter-drawer__collapsed-handle {
        opacity: 1;
        pointer-events: auto;
      }

      /* Main tracker panel stacks round controls and initiative list. */
      .tracker-main {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .field-row {
        display: grid;
        gap: 0.6rem;
        grid-template-columns: minmax(0, 1fr) 140px 150px 110px;
        align-items: end;
      }

      /* Encounter management rows resize for longer inputs and actions. */
      .field-row--encounter-name {
        grid-template-columns: minmax(0, 1fr);
        align-items: center;
      }

      .field-row--participant {
        grid-template-columns: minmax(0, 1fr) 140px 180px 110px;
      }

      .encounter-manager {
        background: rgba(20, 16, 12, 0.85);
        border-radius: 12px;
        border: 1px dashed rgba(201, 162, 74, 0.5);
        padding: 0.8rem;
        margin-bottom: 1rem;
      }

      .encounter-manager h5 {
        font-family: var(--serif);
        margin-bottom: 0.6rem;
        color: var(--gold-bright);
      }

      label {
        font-weight: 600;
      }

      input,
      select,
      button,
      textarea {
        font-family: inherit;
        font-size: 0.95rem;
      }

      input,
      select,
      textarea {
        width: 100%;
        padding: 0.45rem 0.55rem;
        border-radius: 10px;
        border: 1px solid rgba(201, 162, 74, 0.45);
        background: rgba(20, 16, 12, 0.9);
        color: var(--ink);
      }

      button {
        border: none;
        border-radius: 10px;
        padding: 0.6rem 1rem;
        cursor: pointer;
        background: var(--crimson);
        color: #fff;
        font-weight: 600;
        transition: transform 0.1s ease, box-shadow 0.2s ease;
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 16px var(--shadow);
      }

      button.secondary {
        background: rgba(201, 162, 74, 0.18);
        color: var(--ink);
        border: 1px solid rgba(201, 162, 74, 0.5);
      }

      button.ghost {
        background: transparent;
        border: 1px dashed rgba(201, 162, 74, 0.7);
        color: var(--gold-bright);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
      }

      .participant-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.92rem;
      }

      .participant-table th,
      .participant-table td {
        padding: 0.45rem 0.4rem;
        border-bottom: 1px solid rgba(201, 162, 74, 0.35);
        text-align: left;
        vertical-align: top;
      }

      .participant-table th {
        font-family: var(--serif);
      }

      .participant-row.active {
        background: rgba(176, 42, 42, 0.2);
        border-left: 4px solid var(--crimson);
      }

      .marker-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        margin-top: 0.4rem;
      }

      .marker-chip {
        background: rgba(201, 162, 74, 0.15);
        border: 1px solid rgba(201, 162, 74, 0.45);
        padding: 0.25rem 0.45rem;
        border-radius: 999px;
        display: inline-flex;
        gap: 0.35rem;
        align-items: center;
        font-size: 0.82rem;
      }

      .marker-chip button {
        background: transparent;
        border: none;
        color: var(--crimson);
        padding: 0;
        font-size: 0.9rem;
      }

      .initiative-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.8rem;
        margin-top: 1rem;
        align-items: center;
      }

      .round-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
      }

      .round-controls .initiative-controls {
        margin-top: 0;
      }

      .status-pill {
        background: rgba(107, 179, 111, 0.2);
        color: var(--success);
        padding: 0.3rem 0.6rem;
        border-radius: 999px;
        font-size: 0.85rem;
        border: 1px solid rgba(107, 179, 111, 0.4);
      }

      .round-display {
        font-weight: 700;
        color: var(--gold-bright);
      }

      .helper-text {
        font-size: 0.85rem;
        color: var(--ink-muted);
      }

      .legend {
        display: flex;
        gap: 0.6rem;
        flex-wrap: wrap;
        margin-top: 0.6rem;
      }

      .legend span {
        background: rgba(201, 162, 74, 0.2);
        border-radius: 999px;
        padding: 0.2rem 0.6rem;
        font-size: 0.78rem;
      }

      /* Modal (lightbox) styling */
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(22, 16, 11, 0.55);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 1.5rem;
      }

      .modal-overlay.active {
        display: flex;
      }

      .modal {
        background: rgba(33, 25, 18, 0.98);
        border-radius: 18px;
        padding: 1.6rem;
        max-width: 720px;
        width: 100%;
        box-shadow: 0 20px 40px var(--shadow);
        border: 2px solid var(--gold);
      }

      .modal h3 {
        font-family: var(--serif);
        margin-bottom: 0.6rem;
      }

      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.6rem;
        margin-top: 1rem;
        flex-wrap: wrap;
      }

      .modal-list {
        display: grid;
        gap: 0.8rem;
        max-height: 340px;
        overflow: auto;
        padding-right: 0.4rem;
      }

      .modal-item {
        display: grid;
        grid-template-columns: minmax(0, 1fr) 120px;
        gap: 0.8rem;
        align-items: center;
        padding: 0.5rem 0.7rem;
        border-radius: 12px;
        border: 1px solid rgba(201, 162, 74, 0.4);
        background: rgba(20, 16, 12, 0.9);
      }

      .notice {
        background: rgba(227, 160, 66, 0.18);
        border-left: 4px solid var(--warning);
        padding: 0.6rem 0.8rem;
        border-radius: 10px;
        margin-top: 0.6rem;
        font-size: 0.88rem;
      }

      .tracker-footer {
        display: grid;
        gap: 0.8rem;
        margin-top: 1rem;
      }

      .tracker-summary {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        font-weight: 600;
      }

      .is-hidden {
        display: none;
      }

      /* Footer for thematic close */
      footer {
        background: var(--crimson-dark);
        color: var(--ink);
        padding: 0.6rem 0;
        text-align: center;
        font-size: 0.9rem;
      }

      @media (max-width: 920px) {
        .dashboard-grid {
          grid-template-columns: 1fr;
        }

        .tracker-layout {
          grid-template-columns: 1fr;
        }

        .field-row {
          grid-template-columns: 1fr;
        }

        .modal-item {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <!-- Minimal header shared across views for consistent context. -->
    <header class="app-header">
      <div class="container header-frame">
        <p class="header-title">Pathfinder Game Master Toolkit</p>
        <h1 class="header-module" id="active-module">GM Command Dashboard</h1>
        <p class="header-description" id="module-description">
          Plan encounters, manage prep, and jump into core GM tools from a focused dashboard.
        </p>
      </div>
    </header>

    <!-- Main dashboard area with tool access and status panels -->
    <main class="dashboard-main" id="dashboard-view">
      <div class="container dashboard-grid">
        <section aria-label="GM tool dashboard">
          <h2 class="section-title">Core GM Tools</h2>
          <div class="tool-grid">
            <article class="tool-card">
              <h3>Encounter Builder</h3>
              <p>Balance fights, adjust difficulty, and auto-calc XP budgets.</p>
              <div class="tool-meta">
                <span class="tool-tag">Combat</span>
                <span class="tool-tag">XP</span>
              </div>
            </article>
            <article class="tool-card">
              <h3>NPC Vault</h3>
              <p>Store allies and villains with roleplay prompts and stat notes.</p>
              <div class="tool-meta">
                <span class="tool-tag">Social</span>
                <span class="tool-tag">Lore</span>
              </div>
            </article>
            <article class="tool-card">
              <h3>Treasure Generator</h3>
              <p>Roll loot tables and print item cards for quick handouts.</p>
              <div class="tool-meta">
                <span class="tool-tag">Loot</span>
                <span class="tool-tag">Handouts</span>
              </div>
            </article>
            <button
              class="tool-card tool-card--action"
              type="button"
              id="initiative-launch"
              aria-label="Open Initiative Tracker module"
            >
              <h3>Initiative Tracker</h3>
              <p>Track turn order, conditions, and persistent damage rounds.</p>
              <div class="tool-meta">
                <span class="tool-tag">Combat</span>
                <span class="tool-tag">Timing</span>
              </div>
              <span class="tool-launch">Open Tracker →</span>
            </button>
            <article class="tool-card">
              <h3>Session Notes</h3>
              <p>Capture scenes, rulings, and retcons with searchable tags.</p>
              <div class="tool-meta">
                <span class="tool-tag">Narrative</span>
                <span class="tool-tag">Archive</span>
              </div>
            </article>
            <article class="tool-card">
              <h3>Map Library</h3>
              <p>Browse maps, attach encounter markers, and export for VTTs.</p>
              <div class="tool-meta">
                <span class="tool-tag">Exploration</span>
                <span class="tool-tag">VTT</span>
              </div>
            </article>
            <article class="tool-card">
              <h3>Downtime Planner</h3>
              <p>Schedule crafting, research, and settlement activities.</p>
              <div class="tool-meta">
                <span class="tool-tag">Kingdom</span>
                <span class="tool-tag">Crafting</span>
              </div>
            </article>
            <article class="tool-card">
              <h3>Rules Reference</h3>
              <p>Bookmark frequently used rules and house adjustments.</p>
              <div class="tool-meta">
                <span class="tool-tag">Rules</span>
                <span class="tool-tag">Quick</span>
              </div>
            </article>
          </div>
        </section>

        <!-- Right column panels for spotlight info -->
        <aside aria-label="GM status panels">
          <div class="side-panel">
            <h2>Active Threads</h2>
            <ul class="panel-list">
              <li class="panel-item">Resolve the midnight heist before sunrise.</li>
              <li class="panel-item">Track the cult envoy meeting on Day 3.</li>
              <li class="panel-item">Reveal the vault guardian's true motive.</li>
            </ul>
          </div>
          <div class="side-panel">
            <h2>Recent Updates</h2>
            <ul class="panel-list">
              <li class="panel-item">NPC "Captain Vale" promoted to ally status.</li>
              <li class="panel-item">Added 2 new traps to encounter library.</li>
              <li class="panel-item">Session recap shared with players.</li>
            </ul>
          </div>
        </aside>
      </div>
    </main>

    <!-- Initiative tracker module (opens from the dashboard tool card) -->
    <section
      class="initiative-module is-hidden"
      id="initiative-module"
      aria-label="Initiative tracker module"
    >
      <div class="container">
        <!-- Module actions stay in the body so the header stays minimal. -->
        <div class="module-actions">
          <button id="initiative-back" class="ghost" type="button">
            ← Back to Dashboard
          </button>
        </div>

        <section class="initiative-tracker" aria-label="Initiative tracker workspace">
          <p class="helper-text">
            Set up your encounter roster, gather initiative rolls in a lightbox prompt, and manage
            round-by-round conditions with automatic expiry reminders.
          </p>
          <div class="tracker-layout is-collapsed" id="tracker-layout">
            <aside class="encounter-drawer" id="encounter-side-panel" aria-label="Encounter setup and library">
              <!-- Drawer card keeps encounter library and setup unified as a single container. -->
              <div class="encounter-drawer__card encounter-side-panel" id="encounter-panel-content">
                <header class="encounter-drawer__header">
                  <h3 class="encounter-drawer__header-title">Encounter Library</h3>
                  <button
                    id="encounter-panel-toggle"
                    class="encounter-drawer__toggle"
                    type="button"
                    aria-expanded="false"
                    aria-controls="encounter-panel-content"
                    aria-label="Expand Encounter Library"
                  >
                    <span class="encounter-drawer__toggle-icon" aria-hidden="true">▸</span>
                  </button>
                </header>
                <div class="encounter-drawer__body">
                  <div class="tracker-panel encounter-library">
                    <h4>Library</h4>
                    <p class="helper-text">
                      Create a new encounter or load a saved roster into the tracker.
                    </p>
                    <button id="create-encounter" type="button">Create New Encounter</button>
                    <ul id="encounter-list" class="encounter-list" aria-label="Saved encounters"></ul>
                  </div>
                  <div class="tracker-panel">
                    <h4>Setup</h4>
                    <div class="encounter-manager">
                      <h5>Encounter Name</h5>
                      <div class="field-row field-row--encounter-name">
                        <div>
                          <label for="encounter-name">Encounter name</label>
                          <input
                            id="encounter-name"
                            name="encounter-name"
                            type="text"
                            placeholder="e.g. Crimson Guard Ambush"
                          />
                        </div>
                      </div>
                      <p class="helper-text" id="encounter-status-note">
                        Build multiple encounters and save them to browser memory for quick swaps.
                      </p>
                    </div>
                    <form id="participant-form">
                      <div class="field-row field-row--participant">
                        <div>
                          <label for="participant-name">Participant name</label>
                          <input
                            id="participant-name"
                            name="participant-name"
                            type="text"
                            placeholder="e.g. Sir Garrick"
                            required
                          />
                        </div>
                        <div>
                          <label for="participant-type">Type</label>
                          <select id="participant-type" name="participant-type">
                            <option value="Player">Player</option>
                            <option value="NPC">NPC</option>
                            <option value="Monster">Monster</option>
                          </select>
                        </div>
                        <div id="participant-cr-field" class="is-hidden">
                          <label for="participant-cr">CR (XP)</label>
                          <select id="participant-cr" name="participant-cr"></select>
                        </div>
                        <div>
                          <button type="submit">Add</button>
                        </div>
                      </div>
                    </form>
                    <div class="initiative-controls">
                      <button id="save-encounter" class="secondary" type="button">Save / Update</button>
                    </div>
                    <p class="notice">
                      Tip: Use the “Begin Encounter” button in the tracker to open the initiative lightbox and capture
                      rolls for everyone in the roster.
                    </p>
                    <div class="legend">
                      <span>Highlight = current turn</span>
                      <span>Prompt = marker ready to expire</span>
                    </div>
                  </div>
                </div>
              </div>
              <!-- Collapsed handle preserves access to the drawer when the panel is hidden. -->
              <div class="encounter-drawer__collapsed-handle" id="encounter-panel-collapsed-handle">
                <button
                  id="encounter-panel-toggle-collapsed"
                  class="encounter-drawer__collapsed-toggle"
                  type="button"
                  aria-expanded="false"
                  aria-controls="encounter-panel-content"
                  aria-label="Expand Encounter Library"
                >
                  <span aria-hidden="true">▸</span>
                </button>
                <span class="encounter-drawer__collapsed-text">Encounters</span>
              </div>
            </aside>

            <div class="tracker-main">
              <div class="tracker-panel round-controls">
                <h3>Round Controls</h3>
                <p>
                  <span class="round-display">Round:</span>
                  <span id="round-count">1</span>
                </p>
                <p>
                  <strong>Current:</strong>
                  <span id="current-participant">Awaiting initiative...</span>
                </p>
                <div class="initiative-controls">
                  <button id="previous-turn" class="ghost" disabled>Previous Turn</button>
                  <button id="next-turn" disabled>Next Turn</button>
                  <span id="encounter-status" class="status-pill is-hidden">Encounter Active</span>
                </div>
              </div>

              <div class="tracker-panel">
                <h3>Tracker</h3>
                <table class="participant-table" aria-label="Initiative order">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Initiative</th>
                      <th>Markers</th>
                      <th>Actions</th>
                      <th>CR (XP)</th>
                    </tr>
                  </thead>
                  <tbody id="participant-body">
                    <tr>
                      <td colspan="6" class="helper-text">Add participants to begin building the encounter.</td>
                    </tr>
                  </tbody>
                </table>
                <div class="tracker-footer">
                  <div class="tracker-summary">
                    <span>Encounter CR: <span id="encounter-cr">—</span></span>
                    <span>Total XP: <span id="total-xp">0</span></span>
                    <span>XP per player: <span id="xp-per-player">0</span></span>
                  </div>
                  <div class="initiative-controls">
                    <button id="start-encounter" class="secondary" disabled>Begin Encounter</button>
                    <button id="reward-encounter" class="ghost" disabled>Mark Rewards Given</button>
                    <span id="reward-status" class="status-pill is-hidden">Rewards Granted</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>
      </div>
    </section>

    <!-- Initiative input lightbox -->
    <div id="initiative-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal">
        <h3>Enter Initiative Rolls</h3>
        <p class="helper-text">
          Confirm each participant's initiative before starting the encounter.
        </p>
        <div id="initiative-list" class="modal-list"></div>
        <div class="modal-actions">
          <button id="initiative-cancel" class="ghost" type="button">Cancel</button>
          <button id="initiative-confirm" type="button">Begin Encounter</button>
        </div>
      </div>
    </div>

    <!-- Marker editor lightbox -->
    <div id="marker-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal">
        <h3>Add Marker</h3>
        <p class="helper-text">
          Add a condition or reminder with an optional duration. Duration is counted from the
          selected participant's turn.
        </p>
        <form id="marker-form">
          <div class="modal-list">
            <div>
              <label for="marker-target">Add marker to</label>
              <select id="marker-target" required></select>
            </div>
            <div>
              <label for="marker-condition">Preset condition (optional)</label>
              <select id="marker-condition"></select>
            </div>
            <div>
              <label for="marker-label">Custom label</label>
              <input
                id="marker-label"
                type="text"
                placeholder="e.g. Bless +1 morale"
              />
            </div>
            <div>
              <label for="marker-duration">Duration (rounds, optional)</label>
              <input
                id="marker-duration"
                type="number"
                min="1"
                placeholder="e.g. 3"
              />
            </div>
            <div>
              <label for="marker-start">Start counting on</label>
              <select id="marker-start" required></select>
            </div>
          </div>
          <div class="modal-actions">
            <button id="marker-cancel" class="ghost" type="button">Cancel</button>
            <button type="submit">Save Marker</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Marker expiry prompt lightbox -->
    <div id="expiry-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal">
        <h3>Marker Expiring</h3>
        <p id="expiry-message" class="helper-text"></p>
        <div class="modal-actions">
          <button id="expiry-keep" class="ghost" type="button">Keep</button>
          <button id="expiry-remove" type="button">Remove</button>
        </div>
      </div>
    </div>

    <!-- Footer for thematic close -->
    <footer>
      <div class="container">
        <p>Keep your notes close and your dice closer.</p>
      </div>
    </footer>

    <script>
      // ------------------------------
      // Initiative Tracker Logic
      // ------------------------------
      // Local storage schema keeps module data expandable for future tools.
      const STORAGE_KEY = "pfToolkitMemory";
      const STORAGE_VERSION = 1;
      const conditionPresets = [
        "Blinded",
        "Confused",
        "Cowering",
        "Dazzled",
        "Dazed",
        "Deafened",
        "Entangled",
        "Exhausted",
        "Fatigued",
        "Fascinated",
        "Frightened",
        "Grappled",
        "Helpless",
        "Nauseated",
        "Panicked",
        "Paralyzed",
        "Petrified",
        "Pinned",
        "Prone",
        "Shaken",
        "Sickened",
        "Staggered",
        "Stunned",
        "Unconscious",
      ];

      // Challenge rating reference list powers monster XP and encounter summaries.
      const challengeRatings = [
        { value: "1/8", label: "1/8", xp: 50 },
        { value: "1/6", label: "1/6", xp: 65 },
        { value: "1/4", label: "1/4", xp: 100 },
        { value: "1/3", label: "1/3", xp: 135 },
        { value: "1/2", label: "1/2", xp: 200 },
        { value: "1", label: "1", xp: 400 },
        { value: "2", label: "2", xp: 600 },
        { value: "3", label: "3", xp: 800 },
        { value: "4", label: "4", xp: 1200 },
        { value: "5", label: "5", xp: 1600 },
        { value: "6", label: "6", xp: 2400 },
        { value: "7", label: "7", xp: 3200 },
        { value: "8", label: "8", xp: 4800 },
        { value: "9", label: "9", xp: 6400 },
        { value: "10", label: "10", xp: 9600 },
        { value: "11", label: "11", xp: 12800 },
        { value: "12", label: "12", xp: 19200 },
        { value: "13", label: "13", xp: 25600 },
        { value: "14", label: "14", xp: 38400 },
        { value: "15", label: "15", xp: 51200 },
        { value: "16", label: "16", xp: 76800 },
        { value: "17", label: "17", xp: 102400 },
        { value: "18", label: "18", xp: 153600 },
        { value: "19", label: "19", xp: 204800 },
        { value: "20", label: "20", xp: 307200 },
      ];

      const state = {
        participants: [],
        encounterStarted: false,
        rewardsGranted: false,
        round: 1,
        turnIndex: 0,
        promptQueue: [],
        pendingAdvance: false,
        editingTargetId: null,
        activeEncounterId: null,
      };

      // Cache DOM nodes once for performance and clarity.
      const participantForm = document.getElementById("participant-form");
      const participantName = document.getElementById("participant-name");
      const participantType = document.getElementById("participant-type");
      const participantCrField = document.getElementById("participant-cr-field");
      const participantCr = document.getElementById("participant-cr");
      const startEncounterButton = document.getElementById("start-encounter");
      const roundCount = document.getElementById("round-count");
      const currentParticipantLabel = document.getElementById("current-participant");
      const nextTurnButton = document.getElementById("next-turn");
      const previousTurnButton = document.getElementById("previous-turn");
      const participantBody = document.getElementById("participant-body");
      const rewardEncounterButton = document.getElementById("reward-encounter");
      const rewardStatus = document.getElementById("reward-status");
      const encounterCrValue = document.getElementById("encounter-cr");
      const totalXpValue = document.getElementById("total-xp");
      const xpPerPlayerValue = document.getElementById("xp-per-player");
      const encounterStatus = document.getElementById("encounter-status");

      const initiativeModal = document.getElementById("initiative-modal");
      const initiativeList = document.getElementById("initiative-list");
      const initiativeCancel = document.getElementById("initiative-cancel");
      const initiativeConfirm = document.getElementById("initiative-confirm");

      const encounterList = document.getElementById("encounter-list");
      const encounterNameInput = document.getElementById("encounter-name");
      const createEncounterButton = document.getElementById("create-encounter");
      const saveEncounterButton = document.getElementById("save-encounter");
      const encounterStatusNote = document.getElementById("encounter-status-note");

      const markerModal = document.getElementById("marker-modal");
      const markerForm = document.getElementById("marker-form");
      const markerTarget = document.getElementById("marker-target");
      const markerCondition = document.getElementById("marker-condition");
      const markerLabel = document.getElementById("marker-label");
      const markerDuration = document.getElementById("marker-duration");
      const markerStart = document.getElementById("marker-start");
      const markerCancel = document.getElementById("marker-cancel");

      const expiryModal = document.getElementById("expiry-modal");
      const expiryMessage = document.getElementById("expiry-message");
      const expiryKeep = document.getElementById("expiry-keep");
      const expiryRemove = document.getElementById("expiry-remove");

      // Header elements keep the app title concise while highlighting the active module.
      const headerModule = document.getElementById("active-module");
      const headerDescription = document.getElementById("module-description");

      // Module navigation elements keep the dashboard and tracker in separate views.
      const dashboardView = document.getElementById("dashboard-view");
      const initiativeModule = document.getElementById("initiative-module");
      const initiativeLaunch = document.getElementById("initiative-launch");
      const initiativeBack = document.getElementById("initiative-back");
      const encounterPanelToggle = document.getElementById("encounter-panel-toggle");
      const encounterPanelToggleCollapsed = document.getElementById("encounter-panel-toggle-collapsed");
      const encounterPanelCollapsedHandle = document.getElementById("encounter-panel-collapsed-handle");
      const trackerLayout = document.getElementById("tracker-layout");
      const encounterPanelContent = document.getElementById("encounter-panel-content");

      // Single source of truth for header copy across dashboard and module views.
      const headerCopy = {
        dashboard: {
          module: "GM Command Dashboard",
          description: "Plan encounters, manage prep, and jump into core GM tools from a focused dashboard.",
        },
        initiative: {
          module: "Initiative Tracker",
          description: "Run turn order, condition tracking, and round pacing in a compact combat workspace.",
        },
      };

      const updateHeader = (viewKey) => {
        const copy = headerCopy[viewKey];
        if (!copy) {
          return;
        }
        headerModule.textContent = copy.module;
        headerDescription.textContent = copy.description;
      };

      // Control visibility and accessibility state for the encounter drawer toggle.
      const setEncounterPanelVisibility = (isVisible) => {
        trackerLayout.classList.toggle("is-collapsed", !isVisible);
        encounterPanelToggle.setAttribute("aria-expanded", String(isVisible));
        encounterPanelContent.setAttribute("aria-hidden", String(!isVisible));
        encounterPanelToggle.setAttribute(
          "aria-label",
          isVisible ? "Collapse Encounter Library" : "Expand Encounter Library"
        );
        encounterPanelToggle.title = isVisible ? "Collapse Encounter Library" : "Expand Encounter Library";
        encounterPanelToggle.tabIndex = isVisible ? 0 : -1;
        encounterPanelToggleCollapsed.setAttribute("aria-expanded", String(isVisible));
        encounterPanelToggleCollapsed.setAttribute(
          "aria-label",
          isVisible ? "Collapse Encounter Library" : "Expand Encounter Library"
        );
        encounterPanelToggleCollapsed.title = isVisible
          ? "Collapse Encounter Library"
          : "Expand Encounter Library";
        encounterPanelToggleCollapsed.tabIndex = isVisible ? -1 : 0;
        encounterPanelCollapsedHandle.setAttribute("aria-hidden", String(isVisible));
      };

      // Utility helpers keep state changes predictable and documented.
      const generateId = () => `id-${Math.random().toString(16).slice(2, 10)}`;

      const formatXp = (xp) => xp.toLocaleString();

      const getChallengeRatingData = (challengeRating) =>
        challengeRatings.find((rating) => rating.value === challengeRating) ?? null;

      const getXpForChallengeRating = (challengeRating) => getChallengeRatingData(challengeRating)?.xp ?? 0;

      const isMonsterType = (type) => type.toLowerCase() === "monster";

      const isPlayerEquivalent = (type) => {
        const normalized = type.toLowerCase();
        return normalized === "player" || normalized === "npc";
      };

      // Encounter summary logic translates monster CRs into XP totals and a derived CR.
      // NPCs are treated as player equivalents for XP splitting per encounter rules.
      const getEncounterSummary = () => {
        const totalXp = state.participants.reduce((sum, participant) => {
          if (!isMonsterType(participant.type)) {
            return sum;
          }
          return sum + getXpForChallengeRating(participant.challengeRating);
        }, 0);
        const playerCount = state.participants.filter((participant) =>
          isPlayerEquivalent(participant.type)
        ).length;
        const xpPerPlayer = playerCount ? Math.floor(totalXp / playerCount) : 0;
        const closestCr = challengeRatings.reduce((closest, rating) => {
          if (!closest) {
            return rating;
          }
          return Math.abs(rating.xp - totalXp) < Math.abs(closest.xp - totalXp) ? rating : closest;
        }, null);
        return {
          totalXp,
          xpPerPlayer,
          encounterCr: totalXp ? closestCr?.label ?? "—" : "—",
          playerCount,
        };
      };

      const loadMemory = () => {
        const raw = window.localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          return { version: STORAGE_VERSION, modules: { initiative: { encounters: [], activeEncounterId: null } } };
        }
        try {
          const parsed = JSON.parse(raw);
          return {
            version: parsed.version ?? STORAGE_VERSION,
            modules: {
              initiative: {
                encounters: parsed.modules?.initiative?.encounters ?? [],
                activeEncounterId: parsed.modules?.initiative?.activeEncounterId ?? null,
              },
            },
          };
        } catch (error) {
          console.warn("Failed to parse local storage memory, resetting.", error);
          return { version: STORAGE_VERSION, modules: { initiative: { encounters: [], activeEncounterId: null } } };
        }
      };

      const saveMemory = (memory) => {
        window.localStorage.setItem(STORAGE_KEY, JSON.stringify(memory));
      };

      const getInitiativeMemory = () => loadMemory().modules.initiative;

      const updateInitiativeMemory = (updater) => {
        const memory = loadMemory();
        const updated = updater(memory.modules.initiative);
        memory.modules.initiative = updated;
        saveMemory(memory);
        return updated;
      };

      const hydrateStateFromEncounter = (encounter) => {
        state.participants = encounter.participants ?? [];
        state.encounterStarted = encounter.encounterStarted ?? false;
        state.rewardsGranted = encounter.rewardsGranted ?? false;
        state.round = encounter.round ?? 1;
        state.turnIndex = encounter.turnIndex ?? 0;
        state.activeEncounterId = encounter.id ?? null;
        state.promptQueue = [];
        state.pendingAdvance = false;
        state.editingTargetId = null;
      };

      // Keep the encounter name input aligned with the active encounter.
      const updateEncounterNameField = (name = "") => {
        encounterNameInput.value = name;
      };

      const buildEncounterPayload = (overrides = {}) => ({
        id: state.activeEncounterId ?? generateId(),
        name: overrides.name ?? "Untitled Encounter",
        participants: state.participants,
        encounterStarted: state.encounterStarted,
        rewardsGranted: state.rewardsGranted,
        round: state.round,
        turnIndex: state.turnIndex,
        updatedAt: new Date().toISOString(),
      });

      const persistActiveEncounter = () => {
        if (!state.activeEncounterId) {
          return;
        }
        updateInitiativeMemory((initiativeMemory) => {
          const encounters = initiativeMemory.encounters.map((encounter) =>
            encounter.id === state.activeEncounterId
              ? { ...encounter, ...buildEncounterPayload({ name: encounter.name }) }
              : encounter
          );
          return {
            ...initiativeMemory,
            encounters,
          };
        });
      };

      const openModal = (modal) => {
        modal.classList.add("active");
        modal.setAttribute("aria-hidden", "false");
      };

      const closeModal = (modal) => {
        modal.classList.remove("active");
        modal.setAttribute("aria-hidden", "true");
      };

      // Toggle module visibility to keep the initiative tracker off the dashboard.
      const openInitiativeModule = () => {
        dashboardView.classList.add("is-hidden");
        initiativeModule.classList.remove("is-hidden");
        updateHeader("initiative");
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      const closeInitiativeModule = () => {
        initiativeModule.classList.add("is-hidden");
        dashboardView.classList.remove("is-hidden");
        updateHeader("dashboard");
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      const getCurrentParticipant = () => state.participants[state.turnIndex] || null;

      const getCurrentTurnNumber = () => {
        const total = state.participants.length || 1;
        return (state.round - 1) * total + state.turnIndex;
      };

      const getNextTurnNumberForParticipant = (participantId) => {
        const total = state.participants.length || 1;
        const index = state.participants.findIndex((participant) => participant.id === participantId);
        if (index < 0) {
          return getCurrentTurnNumber();
        }
        const currentTurnNumber = getCurrentTurnNumber();
        const currentRoundIndex = state.turnIndex;
        if (index >= currentRoundIndex) {
          return (state.round - 1) * total + index;
        }
        return state.round * total + index;
      };

      const updateEncounterControls = () => {
        const hasParticipants = state.participants.length > 0;
        startEncounterButton.disabled = !hasParticipants;
        rewardEncounterButton.disabled = !state.encounterStarted || !hasParticipants;
        nextTurnButton.disabled = !state.encounterStarted;
        previousTurnButton.disabled = !state.encounterStarted;
        encounterStatus.classList.toggle("is-hidden", !state.encounterStarted);
        rewardStatus.classList.toggle("is-hidden", !state.rewardsGranted);
      };

      const updateRoundDisplay = () => {
        roundCount.textContent = state.round;
        const current = getCurrentParticipant();
        currentParticipantLabel.textContent = current
          ? `${current.name} (${current.type})`
          : "Awaiting initiative...";
      };

      const updateEncounterSummary = () => {
        const summary = getEncounterSummary();
        encounterCrValue.textContent = summary.encounterCr;
        totalXpValue.textContent = formatXp(summary.totalXp);
        xpPerPlayerValue.textContent = formatXp(summary.xpPerPlayer);
      };

      const updateMarkerSelects = () => {
        const options = state.participants
          .map((participant) => `<option value="${participant.id}">${participant.name}</option>`)
          .join("");
        markerTarget.innerHTML = options;
        markerStart.innerHTML = options;
      };

      const seedChallengeRatings = () => {
        participantCr.innerHTML = challengeRatings
          .map((rating) => `<option value="${rating.value}">CR ${rating.label} (${formatXp(rating.xp)} XP)</option>`)
          .join("");
      };

      const updateParticipantCrVisibility = () => {
        const showCr = isMonsterType(participantType.value);
        participantCrField.classList.toggle("is-hidden", !showCr);
        if (showCr && !participantCr.value) {
          participantCr.value = challengeRatings[0]?.value ?? "";
        }
      };

      const formatCrXp = (participant) => {
        if (!isMonsterType(participant.type)) {
          return "—";
        }
        if (!participant.challengeRating) {
          return "CR —";
        }
        const xp = getXpForChallengeRating(participant.challengeRating);
        return `CR ${participant.challengeRating} (${formatXp(xp)} XP)`;
      };

      // Render the encounter library list for quick selection and deletion.
      const renderEncounterLibrary = (initiativeMemory) => {
        const encounters = initiativeMemory.encounters ?? [];
        if (!encounters.length) {
          encounterList.innerHTML = '<li class="encounter-empty">No saved encounters yet.</li>';
          return;
        }
        encounterList.innerHTML = encounters
          .map((encounter) => {
            const isActive = encounter.id === initiativeMemory.activeEncounterId;
            const displayName = encounter.name || "Untitled Encounter";
            return `
              <li class="encounter-entry ${isActive ? "is-active" : ""}">
                <div class="encounter-entry-title">${displayName}</div>
                <div class="encounter-actions">
                  <button
                    type="button"
                    class="encounter-action"
                    data-encounter-view="${encounter.id}"
                  >
                    View
                  </button>
                  <button
                    type="button"
                    class="encounter-action"
                    data-encounter-defeat="${encounter.id}"
                  >
                    Defeat
                  </button>
                </div>
              </li>
            `;
          })
          .join("");
      };

      const updateEncounterStatusNote = (message, isWarning = false) => {
        encounterStatusNote.textContent = message;
        encounterStatusNote.style.color = isWarning ? "var(--warning)" : "var(--ink-muted)";
      };

      const loadEncounterLibrary = () => {
        const initiativeMemory = getInitiativeMemory();
        renderEncounterLibrary(initiativeMemory);
        if (initiativeMemory.activeEncounterId) {
          const active = initiativeMemory.encounters.find(
            (encounter) => encounter.id === initiativeMemory.activeEncounterId
          );
          if (active) {
            hydrateStateFromEncounter(active);
            updateEncounterNameField(active.name);
          } else {
            updateEncounterNameField("");
          }
        } else {
          updateEncounterNameField("");
        }
        renderParticipants();
        updateEncounterControls();
        updateRoundDisplay();
        updateMarkerSelects();
        updateParticipantCrVisibility();
      };

      const renderParticipants = () => {
        if (!state.participants.length) {
          participantBody.innerHTML =
            '<tr><td colspan="6" class="helper-text">Add participants to begin building the encounter.</td></tr>';
          updateEncounterSummary();
          return;
        }

        participantBody.innerHTML = state.participants
          .map((participant, index) => {
            const markers = participant.markers
              .map((marker) => {
                const durationText = marker.duration
                  ? `(${marker.duration}r)`
                  : "(end of turn)";
                return `
                  <span class="marker-chip">
                    ${marker.label} ${durationText}
                    <button type="button" aria-label="Remove marker" data-remove-marker="${marker.id}">
                      ✕
                    </button>
                  </span>
                `;
              })
              .join("");

            return `
              <tr class="participant-row ${state.encounterStarted && index === state.turnIndex ? "active" : ""}">
                <td>${participant.name}</td>
                <td>${participant.type}</td>
                <td>${participant.initiative ?? "—"}</td>
                <td>
                  ${markers || "<span class=\"helper-text\">No markers</span>"}
                </td>
                <td>
                  <div style="display: flex; flex-wrap: wrap; gap: 0.4rem;">
                    <button type="button" class="secondary" data-add-marker="${participant.id}">
                      Add Marker
                    </button>
                    <button type="button" class="ghost" data-remove-participant="${participant.id}">
                      Remove
                    </button>
                  </div>
                </td>
                <td>${formatCrXp(participant)}</td>
              </tr>
            `;
          })
          .join("");
        updateEncounterSummary();
      };

      // Render the initiative lightbox list with inputs for each participant.
      const renderInitiativeModal = () => {
        initiativeList.innerHTML = state.participants
          .map((participant) => {
            return `
              <div class="modal-item">
                <div>
                  <strong>${participant.name}</strong>
                  <div class="helper-text">${participant.type}</div>
                </div>
                <div>
                  <label class="helper-text" for="initiative-${participant.id}">Initiative</label>
                  <input
                    id="initiative-${participant.id}"
                    type="number"
                    inputmode="numeric"
                    min="-5"
                    value="${participant.initiative ?? ""}"
                  />
                </div>
              </div>
            `;
          })
          .join("");
      };

      const seedConditionPresets = () => {
        markerCondition.innerHTML = [
          '<option value="">-- Select condition --</option>',
          ...conditionPresets.map((preset) => `<option value="${preset}">${preset}</option>`),
        ].join("");
      };

      const seedChallengeRatingOptions = () => {
        seedChallengeRatings();
        updateParticipantCrVisibility();
      };

      // Initialize baseline UI.
      updateHeader("dashboard");
      // Keep encounter tools collapsed until the GM expands them.
      setEncounterPanelVisibility(false);
      seedConditionPresets();
      seedChallengeRatingOptions();
      updateEncounterControls();
      updateRoundDisplay();
      loadEncounterLibrary();

      // Wire module navigation events for the initiative tracker entry point.
      initiativeLaunch.addEventListener("click", openInitiativeModule);
      initiativeBack.addEventListener("click", closeInitiativeModule);
      // Shared toggle keeps both expanded and collapsed controls in sync.
      const toggleEncounterPanel = () => {
        const isExpanded = encounterPanelToggle.getAttribute("aria-expanded") === "true";
        setEncounterPanelVisibility(!isExpanded);
      };
      encounterPanelToggle.addEventListener("click", toggleEncounterPanel);
      encounterPanelToggleCollapsed.addEventListener("click", toggleEncounterPanel);
      participantType.addEventListener("change", updateParticipantCrVisibility);

      participantForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const name = participantName.value.trim();
        const type = participantType.value;
        if (!name) {
          return;
        }
        const challengeRating = isMonsterType(type) ? participantCr.value : null;
        state.participants.push({
          id: generateId(),
          name,
          type,
          challengeRating,
          initiative: null,
          markers: [],
        });
        state.rewardsGranted = false;
        participantName.value = "";
        participantCr.value = challengeRatings[0]?.value ?? "";
        renderParticipants();
        updateEncounterControls();
        updateMarkerSelects();
        persistActiveEncounter();
      });

      startEncounterButton.addEventListener("click", () => {
        if (!state.participants.length) {
          return;
        }
        renderInitiativeModal();
        openModal(initiativeModal);
      });

      rewardEncounterButton.addEventListener("click", () => {
        if (!state.encounterStarted) {
          return;
        }
        state.rewardsGranted = true;
        updateEncounterControls();
        updateEncounterStatusNote("Rewards marked as distributed.");
        persistActiveEncounter();
      });

      initiativeCancel.addEventListener("click", () => {
        closeModal(initiativeModal);
      });

      initiativeConfirm.addEventListener("click", () => {
        state.participants = state.participants.map((participant) => {
          const input = document.getElementById(`initiative-${participant.id}`);
          const value = Number.parseInt(input.value, 10);
          return {
            ...participant,
            initiative: Number.isNaN(value) ? 0 : value,
          };
        });
        state.participants.sort((a, b) => {
          if (b.initiative !== a.initiative) {
            return b.initiative - a.initiative;
          }
          return a.name.localeCompare(b.name);
        });
        state.encounterStarted = true;
        state.rewardsGranted = false;
        state.round = 1;
        state.turnIndex = 0;
        closeModal(initiativeModal);
        renderParticipants();
        updateEncounterControls();
        updateRoundDisplay();
        updateMarkerSelects();
        persistActiveEncounter();
      });

      participantBody.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const removeId = target.getAttribute("data-remove-participant");
        const addMarkerId = target.getAttribute("data-add-marker");
        const removeMarkerId = target.getAttribute("data-remove-marker");

        if (removeId) {
          state.participants = state.participants.filter((participant) => participant.id !== removeId);
          if (state.turnIndex >= state.participants.length) {
            state.turnIndex = Math.max(0, state.participants.length - 1);
          }
          state.rewardsGranted = false;
          renderParticipants();
          updateEncounterControls();
          updateRoundDisplay();
          updateMarkerSelects();
          persistActiveEncounter();
          return;
        }

        if (addMarkerId) {
          // Default marker timing should follow the active turn, not the target, for GM speed.
          const currentParticipant = getCurrentParticipant();
          const defaultStartId = currentParticipant ? currentParticipant.id : addMarkerId;
          state.editingTargetId = addMarkerId;
          updateMarkerSelects();
          markerTarget.value = addMarkerId;
          markerStart.value = defaultStartId;
          markerCondition.value = "";
          markerLabel.value = "";
          markerDuration.value = "";
          openModal(markerModal);
          return;
        }

        if (removeMarkerId) {
          state.participants = state.participants.map((participant) => ({
            ...participant,
            markers: participant.markers.filter((marker) => marker.id !== removeMarkerId),
          }));
          renderParticipants();
          persistActiveEncounter();
        }
      });

      markerCancel.addEventListener("click", () => {
        closeModal(markerModal);
      });

      markerForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const targetId = markerTarget.value;
        const startId = markerStart.value;
        const durationValue = markerDuration.value ? Number.parseInt(markerDuration.value, 10) : null;
        const conditionValue = markerCondition.value.trim();
        const customLabelValue = markerLabel.value.trim();
        const label = customLabelValue || conditionValue;
        if (!targetId || !startId || !label) {
          return;
        }

        const startTurnNumber = getNextTurnNumberForParticipant(startId);
        const total = state.participants.length || 1;
        const durationRounds = durationValue && durationValue > 0 ? durationValue : null;
        const endTurnNumber = durationRounds ? startTurnNumber + durationRounds * total : null;

        const marker = {
          id: generateId(),
          label,
          duration: durationRounds,
          startParticipantId: startId,
          startTurnNumber,
          endTurnNumber,
        };

        state.participants = state.participants.map((participant) => {
          if (participant.id !== targetId) {
            return participant;
          }
          return {
            ...participant,
            markers: [...participant.markers, marker],
          };
        });

        closeModal(markerModal);
        renderParticipants();
        persistActiveEncounter();
      });

      const queuePrompt = (participant, marker, reason) => {
        state.promptQueue.push({ participant, marker, reason });
      };

      const processPromptQueue = () => {
        if (!state.promptQueue.length) {
          closeModal(expiryModal);
          if (state.pendingAdvance) {
            completeTurnAdvance();
          }
          return;
        }
        const nextPrompt = state.promptQueue[0];
        const reasonText = nextPrompt.reason === "duration"
          ? "Duration complete"
          : "End of turn reminder";
        expiryMessage.textContent = `${reasonText}: Remove "${nextPrompt.marker.label}" from ${nextPrompt.participant.name}?`;
        openModal(expiryModal);
      };

      expiryKeep.addEventListener("click", () => {
        state.promptQueue.shift();
        processPromptQueue();
      });

      expiryRemove.addEventListener("click", () => {
        const { marker } = state.promptQueue.shift();
        state.participants = state.participants.map((participant) => ({
          ...participant,
          markers: participant.markers.filter((existing) => existing.id !== marker.id),
        }));
        renderParticipants();
        processPromptQueue();
        persistActiveEncounter();
      });

      const checkForExpiryPrompts = () => {
        const current = getCurrentParticipant();
        if (!current) {
          return;
        }
        const currentTurnNumber = getCurrentTurnNumber();
        current.markers.forEach((marker) => {
          if (!marker.duration) {
            queuePrompt(current, marker, "end-turn");
          }
        });
        state.participants.forEach((participant) => {
          participant.markers.forEach((marker) => {
            if (
              marker.duration &&
              marker.endTurnNumber !== null &&
              marker.startParticipantId === current.id &&
              marker.endTurnNumber === currentTurnNumber
            ) {
              queuePrompt(participant, marker, "duration");
            }
          });
        });
      };

      const completeTurnAdvance = () => {
        state.pendingAdvance = false;
        if (!state.participants.length) {
          return;
        }
        if (state.turnIndex < state.participants.length - 1) {
          state.turnIndex += 1;
        } else {
          state.turnIndex = 0;
          state.round += 1;
        }
        renderParticipants();
        updateRoundDisplay();
        persistActiveEncounter();
      };

      const completeTurnRewind = () => {
        if (!state.participants.length) {
          return;
        }
        if (state.turnIndex > 0) {
          state.turnIndex -= 1;
        } else if (state.round > 1) {
          state.round -= 1;
          state.turnIndex = state.participants.length - 1;
        }
        renderParticipants();
        updateRoundDisplay();
        persistActiveEncounter();
      };

      nextTurnButton.addEventListener("click", () => {
        if (!state.encounterStarted) {
          return;
        }
        state.promptQueue = [];
        checkForExpiryPrompts();
        if (state.promptQueue.length) {
          state.pendingAdvance = true;
          processPromptQueue();
          return;
        }
        completeTurnAdvance();
      });

      previousTurnButton.addEventListener("click", () => {
        if (!state.encounterStarted) {
          return;
        }
        completeTurnRewind();
      });

      // Encounter management handlers wire local storage for persistent switching.
      const loadEncounterById = (selectedId) => {
        if (!selectedId) {
          return;
        }
        const initiativeMemory = updateInitiativeMemory((memory) => ({
          ...memory,
          activeEncounterId: selectedId,
        }));
        const selectedEncounter = initiativeMemory.encounters.find(
          (encounter) => encounter.id === selectedId
        );
        if (!selectedEncounter) {
          return;
        }
        hydrateStateFromEncounter(selectedEncounter);
        updateEncounterNameField(selectedEncounter.name);
        renderEncounterLibrary(initiativeMemory);
        updateEncounterControls();
        updateRoundDisplay();
        renderParticipants();
        updateMarkerSelects();
        updateEncounterStatusNote(`Loaded "${selectedEncounter.name}".`);
      };

      const deleteEncounterById = (encounterId) => {
        const initiativeMemory = updateInitiativeMemory((memory) => {
          const encounters = memory.encounters.filter((encounter) => encounter.id !== encounterId);
          const nextActiveId = encounters[0]?.id ?? null;
          return { ...memory, encounters, activeEncounterId: nextActiveId };
        });
        const nextActive = initiativeMemory.encounters.find(
          (encounter) => encounter.id === initiativeMemory.activeEncounterId
        );
        if (nextActive) {
          hydrateStateFromEncounter(nextActive);
          updateEncounterNameField(nextActive.name);
        } else {
          hydrateStateFromEncounter({
            id: null,
            name: "",
            participants: [],
            encounterStarted: false,
            rewardsGranted: false,
            round: 1,
            turnIndex: 0,
          });
          updateEncounterNameField("");
        }
        renderEncounterLibrary(initiativeMemory);
        updateEncounterControls();
        updateRoundDisplay();
        renderParticipants();
        updateMarkerSelects();
        updateEncounterStatusNote("Encounter removed from local memory.");
      };

      createEncounterButton.addEventListener("click", () => {
        const name = encounterNameInput.value.trim();
        if (!name) {
          updateEncounterStatusNote("Add a name before creating a new encounter.", true);
          return;
        }
        const newEncounter = {
          id: generateId(),
          name,
          participants: [],
          encounterStarted: false,
          rewardsGranted: false,
          round: 1,
          turnIndex: 0,
          updatedAt: new Date().toISOString(),
        };
        const initiativeMemory = updateInitiativeMemory((memory) => ({
          ...memory,
          encounters: [...memory.encounters, newEncounter],
          activeEncounterId: newEncounter.id,
        }));
        hydrateStateFromEncounter(newEncounter);
        updateEncounterNameField(newEncounter.name);
        renderEncounterLibrary(initiativeMemory);
        updateEncounterControls();
        updateRoundDisplay();
        renderParticipants();
        updateMarkerSelects();
        updateEncounterStatusNote(`Created and opened "${newEncounter.name}".`);
      });

      saveEncounterButton.addEventListener("click", () => {
        if (!state.activeEncounterId) {
          updateEncounterStatusNote("Create or select an encounter before saving.", true);
          return;
        }
        const name = encounterNameInput.value.trim();
        if (!name) {
          updateEncounterStatusNote("Add a name before saving the encounter.", true);
          return;
        }
        const initiativeMemory = updateInitiativeMemory((memory) => {
          const encounters = memory.encounters.map((encounter) =>
            encounter.id === state.activeEncounterId
              ? { ...encounter, ...buildEncounterPayload({ name }) }
              : encounter
          );
          return { ...memory, encounters };
        });
        renderEncounterLibrary(initiativeMemory);
        updateEncounterStatusNote("Encounter saved to local memory.");
      });

      encounterList.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const viewId = target.getAttribute("data-encounter-view");
        if (viewId) {
          loadEncounterById(viewId);
          return;
        }
        const defeatId = target.getAttribute("data-encounter-defeat");
        if (defeatId) {
          deleteEncounterById(defeatId);
        }
      });
    </script>
  </body>
</html>
