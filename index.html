<!DOCTYPE html>
<html lang="en">
  <head>
    <!--
      Pathfinder GM Toolkit - Dashboard
      Purpose: Provide a focused dashboard view for core GM tools.
    -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pathfinder GM Toolkit</title>
    <style>
      :root {
        /* Brand palette tuned for Pathfinder dark mode styling. */
        --parchment: #f3e4c3;
        --parchment-dark: #cdb78a;
        --parchment-night: #2a2218;
        --parchment-shadow: #1d170f;
        --ink: #f5ead3;
        --ink-muted: #c7b79a;
        --crimson: #b02a2a;
        --crimson-dark: #7a1414;
        --gold: #c9a24a;
        --gold-bright: #e8c877;
        --shadow: rgba(8, 6, 4, 0.55);
        --success: #6bb36f;
        --warning: #e3a042;
        /* Typography stack */
        --serif: "Georgia", "Times New Roman", serif;
        --sans: "Trebuchet MS", "Segoe UI", sans-serif;
      }

      /* Global reset and base typography */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: var(--sans);
        color: var(--ink);
        background: radial-gradient(circle at top, #3a2f22 0%, var(--parchment-night) 55%, #140f0a 100%);
        line-height: 1.6;
      }

      /* Full-width layout container to use the entire viewport width. */
      .container {
        width: 100%;
        max-width: 100%;
        margin: 0 auto;
        padding: 0 clamp(1.25rem, 3vw, 2.5rem);
      }

      /* Minimal header with only app title, active module, and descriptor. */
      .app-header {
        padding: 1rem 0 0.8rem;
      }

      .header-frame {
        background: rgba(33, 25, 18, 0.95);
        border-radius: 16px;
        padding: 1rem 1.4rem;
        box-shadow: 0 16px 26px var(--shadow);
        border: 1px solid rgba(201, 162, 74, 0.55);
      }

      .header-title {
        font-family: var(--serif);
        font-size: clamp(1.2rem, 2vw, 1.5rem);
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--ink-muted);
      }

      .header-module {
        font-family: var(--serif);
        font-size: clamp(1.6rem, 2.4vw, 2.1rem);
        margin-top: 0.2rem;
      }

      /* Allow header copy to span the full layout width. */
      .header-description {
        margin-top: 0.35rem;
        max-width: 100%;
        color: var(--ink-muted);
      }

      /* Dashboard main grid */
      .dashboard-main {
        padding: 1.1rem 0 2rem;
      }

      .dashboard-grid {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: minmax(0, 2.2fr) minmax(0, 1fr);
      }

      /* Tool grid styles */
      .tool-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }

      /* Section title styling keeps headings compact. */
      .section-title {
        font-family: var(--serif);
        margin-bottom: 0.6rem;
        font-size: 1.2rem;
      }

      .tool-card {
        background: rgba(32, 25, 18, 0.92);
        border-radius: 14px;
        padding: 1rem 1.1rem;
        border-left: 4px solid var(--crimson);
        box-shadow: 0 10px 18px var(--shadow);
      }

      .tool-card--action {
        width: 100%;
        border: none;
        text-align: left;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease;
        padding: 1rem 1.1rem;
        background: rgba(32, 25, 18, 0.92);
        color: inherit;
      }

      .tool-card--action:hover,
      .tool-card--action:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 16px 26px var(--shadow);
        outline: none;
      }

      .tool-card h3 {
        margin-bottom: 0.5rem;
        font-family: var(--serif);
        color: var(--gold-bright);
      }

      .tool-card p {
        margin-bottom: 0.8rem;
      }

      .tool-meta {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        font-size: 0.85rem;
      }

      .tool-tag {
        padding: 0.2rem 0.6rem;
        border-radius: 999px;
        background: rgba(201, 162, 74, 0.2);
        color: var(--ink-muted);
      }

      .tool-launch {
        margin-top: 0.8rem;
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        background: transparent;
        color: var(--gold-bright);
        border: 1px dashed rgba(201, 162, 74, 0.7);
      }

      /* Planning workspace styles keep the home view campaign-first rather than tool-first. */
      .planning-layout {
        display: grid;
        gap: 1.2rem;
      }

      .planning-card {
        background: rgba(32, 25, 18, 0.92);
        border-radius: 14px;
        padding: 1rem 1.1rem;
        border-left: 4px solid var(--gold);
        box-shadow: 0 10px 18px var(--shadow);
      }

      .planning-card h3 {
        margin-bottom: 0.45rem;
        font-family: var(--serif);
        color: var(--gold-bright);
      }

      .planning-list {
        list-style: none;
        display: grid;
        gap: 0.7rem;
      }

      .planning-list li {
        background: rgba(20, 16, 11, 0.92);
        border-radius: 10px;
        padding: 0.6rem 0.8rem;
        border: 1px solid rgba(201, 162, 74, 0.3);
      }

      .planning-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.8rem;
      }

      .primary-action {
        border: 1px solid rgba(201, 162, 74, 0.65);
        border-radius: 10px;
        background: linear-gradient(135deg, rgba(176, 42, 42, 0.96), rgba(122, 20, 20, 0.96));
        color: var(--ink);
        padding: 0.65rem 1rem;
        cursor: pointer;
        font-weight: 700;
        transition: transform 0.15s ease;
      }

      .primary-action:hover,
      .primary-action:focus-visible {
        transform: translateY(-2px);
        outline: none;
      }

      .planning-tool-tabs {
        display: flex;
        flex-wrap: wrap;
        gap: 0.7rem;
        margin-top: 0.8rem;
      }

      .secondary-tab {
        border: 1px dashed rgba(201, 162, 74, 0.65);
        border-radius: 10px;
        background: rgba(24, 19, 13, 0.9);
        color: var(--ink);
        padding: 0.55rem 0.85rem;
        cursor: pointer;
      }

      .planning-card--planned {
        border-left-color: rgba(227, 160, 66, 0.9);
      }

      .planned-note {
        margin-top: 0.5rem;
        display: inline-block;
        font-size: 0.85rem;
        color: var(--warning);
      }

      /* Side panels for notes and status */
      .side-panel {
        background: rgba(34, 26, 19, 0.94);
        border-radius: 18px;
        padding: 1.2rem;
        border: 1px dashed rgba(201, 162, 74, 0.6);
        box-shadow: 0 10px 18px var(--shadow);
      }

      .side-panel + .side-panel {
        margin-top: 1.5rem;
      }

      .side-panel h2 {
        font-family: var(--serif);
        margin-bottom: 0.8rem;
      }

      .panel-list {
        list-style: none;
        display: grid;
        gap: 0.75rem;
      }

      .panel-item {
        background: rgba(26, 20, 14, 0.9);
        border-radius: 12px;
        padding: 0.7rem 0.9rem;
        border-left: 4px solid var(--gold);
      }

      /* Initiative tracker layout (compact header to emphasize workspace). */
      .initiative-module {
        padding: 1.1rem 0 2rem;
      }

      /* NPC vault module keeps the roster layout distinct from combat tools. */
      .npc-module {
        padding: 1.1rem 0 2.2rem;
      }

      /* Session notes module presents prep, live notes, and reflection in a calm workspace. */
      .session-module {
        padding: 1.1rem 0 2.2rem;
      }

      /* Workspace layout pairs a timeline rail with a scrollable notes pane. */
      .session-workspace {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: minmax(0, 0.75fr) minmax(0, 1.25fr);
        align-items: start;
      }

      /* Timeline rail keeps the session list visible without crowding the notes pane. */
      .session-timeline {
        background: rgba(28, 22, 16, 0.94);
        border-radius: 16px;
        padding: 1rem;
        border: 1px solid rgba(201, 162, 74, 0.5);
        box-shadow: 0 12px 20px var(--shadow);
        max-height: 72vh;
        overflow-y: auto;
      }

      .session-timeline__header {
        display: grid;
        gap: 0.3rem;
        margin-bottom: 0.8rem;
      }

      .session-timeline__list {
        list-style: none;
        display: grid;
        gap: 0.8rem;
      }

      .session-timeline-card {
        background: rgba(22, 17, 12, 0.92);
        border-radius: 14px;
        padding: 0.8rem 0.9rem;
        border: 1px solid rgba(201, 162, 74, 0.4);
        display: grid;
        gap: 0.5rem;
        box-shadow: inset 0 0 0 1px rgba(201, 162, 74, 0.08);
      }

      .session-timeline-card.is-active {
        border-color: var(--gold-bright);
        box-shadow: 0 0 0 1px rgba(232, 200, 119, 0.35);
      }

      .session-timeline-title {
        font-weight: 600;
        color: var(--ink);
      }

      .session-timeline-meta {
        color: var(--ink-muted);
        font-size: 0.85rem;
      }

      .session-timeline-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .session-timeline-actions button {
        font-size: 0.78rem;
        padding: 0.3rem 0.55rem;
      }

      /* Notes pane scrolls independently so the timeline stays anchored. */
      .session-notes-pane {
        background: rgba(24, 18, 13, 0.94);
        border-radius: 16px;
        padding: 1rem 1.1rem;
        border: 1px solid rgba(201, 162, 74, 0.5);
        box-shadow: 0 14px 22px var(--shadow);
        max-height: 72vh;
        overflow-y: auto;
      }

      .session-notes-header {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
      }

      .session-view {
        display: none;
      }

      .session-view.is-active {
        display: grid;
        gap: 1rem;
      }

      /* Stack session content cards with consistent spacing. */
      .session-column {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
      }

      /* Session cards reuse the toolkit panel styling with subtle contrast. */
      .session-card {
        background: rgba(24, 18, 13, 0.92);
        border-radius: 14px;
        padding: 1rem 1.1rem;
        border: 1px solid rgba(201, 162, 74, 0.45);
        box-shadow: 0 12px 20px var(--shadow);
      }

      .session-card h3 {
        font-family: var(--serif);
        margin-bottom: 0.6rem;
        color: var(--gold-bright);
      }

      /* Session grid keeps metadata fields aligned without overwhelming the layout. */
      .session-grid {
        display: grid;
        gap: 0.75rem;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      }

      /* Shorter textareas avoid visual heaviness during live play. */
      .session-textarea--short {
        min-height: 90px;
      }

      .session-textarea--tall {
        min-height: 140px;
      }

      /* Primary session action row holds save/reset and status messaging. */
      .session-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      .session-status {
        font-size: 0.85rem;
        color: var(--ink-muted);
      }

      /* Summary rows keep prep/run highlights visible in later views. */
      .session-summary-grid {
        display: grid;
        gap: 0.6rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .session-summary-item {
        background: rgba(18, 14, 10, 0.82);
        border-radius: 10px;
        padding: 0.6rem 0.75rem;
        border-left: 3px solid var(--gold);
      }

      .session-summary-item strong {
        display: block;
        font-size: 0.78rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--ink-muted);
        margin-bottom: 0.2rem;
      }

      /* Compact action row keeps navigation visible without expanding the header. */
      .module-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.8rem;
        margin-bottom: 0.9rem;
      }

      /* NPC vault layout balances roster list with an active detail panel. */
      .npc-layout {
        display: grid;
        gap: 1.4rem;
        grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
        align-items: start;
      }

      .npc-column {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
      }

      /* NPC form sections create a guided, grouped layout for faster data entry. */
      .npc-form-sections {
        display: grid;
        gap: 1rem;
      }

      .npc-form-section {
        background: rgba(18, 14, 10, 0.82);
        border-radius: 14px;
        padding: 0.85rem;
        border: 1px solid rgba(201, 162, 74, 0.35);
        box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.25);
      }

      .npc-form-section__header {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
        margin-bottom: 0.65rem;
      }

      .npc-form-section__title {
        font-family: var(--serif);
        color: var(--gold-bright);
        font-size: 1rem;
      }

      .npc-form-section__hint {
        color: var(--ink-muted);
        font-size: 0.85rem;
      }

      .npc-section-grid {
        display: grid;
        gap: 0.75rem;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }

      .npc-section-grid--compact {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }

      .npc-section-grid--full {
        grid-template-columns: minmax(0, 1fr);
      }

      .npc-section-grid textarea {
        min-height: 90px;
      }

      .npc-form-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        margin-top: 0.8rem;
      }

      .npc-list {
        list-style: none;
        display: grid;
        gap: 0.7rem;
      }

      .npc-card {
        background: rgba(24, 18, 13, 0.92);
        border-radius: 12px;
        padding: 0.75rem 0.85rem;
        border: 1px solid rgba(201, 162, 74, 0.45);
        display: grid;
        gap: 0.45rem;
      }

      .npc-card.is-active {
        border-color: var(--gold-bright);
        box-shadow: 0 0 0 1px rgba(232, 200, 119, 0.25);
      }

      .npc-card__title {
        font-weight: 600;
        color: var(--ink);
      }

      .npc-card__meta {
        color: var(--ink-muted);
        font-size: 0.85rem;
      }

      .npc-card__actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .npc-card__actions button {
        font-size: 0.85rem;
      }

      .npc-detail {
        display: grid;
        gap: 0.75rem;
      }

      .npc-detail-item {
        background: rgba(20, 16, 12, 0.88);
        border-radius: 10px;
        padding: 0.55rem 0.7rem;
        border-left: 4px solid var(--gold);
      }

      .npc-detail-label {
        font-size: 0.78rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--ink-muted);
      }

      .npc-detail-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        margin-top: 0.6rem;
      }

      /* NPC gallery highlights existing profiles as the module landing view. */
      .npc-gallery-panel__header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
        margin-bottom: 0.8rem;
      }

      .npc-gallery-panel__actions {
        display: flex;
        gap: 0.6rem;
        flex-wrap: wrap;
      }

      .npc-gallery-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .npc-gallery-card {
        background: rgba(24, 18, 13, 0.92);
        border-radius: 14px;
        padding: 0.85rem 0.95rem;
        border: 1px solid rgba(201, 162, 74, 0.45);
        display: grid;
        gap: 0.5rem;
        box-shadow: 0 12px 20px var(--shadow);
      }

      .npc-gallery-card.is-active {
        border-color: var(--gold-bright);
        box-shadow: 0 0 0 1px rgba(232, 200, 119, 0.35);
      }

      .npc-gallery-card__meta {
        color: var(--ink-muted);
        font-size: 0.82rem;
      }

      .npc-gallery-card__tags {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .npc-gallery-card__actions {
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
      }

      /* NPC creation wizard styling keeps the modal guided and scannable. */
      .modal--wide {
        max-width: 860px;
      }

      .npc-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
        margin-bottom: 0.8rem;
      }

      /* Creature library module aligns roster management with printable stat cards. */
      .creature-module {
        padding: 1.1rem 0 2.2rem;
      }

      .creature-layout {
        display: grid;
        gap: 1.4rem;
        grid-template-columns: minmax(0, 1.05fr) minmax(0, 1fr);
        align-items: start;
      }

      .creature-column {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
      }

      .creature-list {
        display: grid;
        gap: 0.8rem;
      }

      .creature-card {
        background: rgba(24, 18, 13, 0.92);
        border-radius: 12px;
        padding: 0.75rem 0.85rem;
        border: 1px solid rgba(201, 162, 74, 0.45);
        display: grid;
        gap: 0.45rem;
      }

      .creature-card.is-active {
        border-color: var(--gold-bright);
        box-shadow: 0 0 0 1px rgba(232, 200, 119, 0.25);
      }

      .creature-card__title {
        font-weight: 600;
        color: var(--ink);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.6rem;
      }

      .creature-card__meta {
        color: var(--ink-muted);
        font-size: 0.85rem;
      }

      .creature-card__actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .creature-form {
        display: grid;
        gap: 1rem;
      }

      .creature-form-sections {
        display: grid;
        gap: 1rem;
      }

      .creature-form-section {
        background: rgba(18, 14, 10, 0.82);
        border-radius: 14px;
        padding: 0.85rem;
        border: 1px solid rgba(201, 162, 74, 0.35);
        box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.25);
      }

      .creature-form-section__header {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
        margin-bottom: 0.65rem;
      }

      .creature-form-section__title {
        font-family: var(--serif);
        color: var(--gold-bright);
        font-size: 1rem;
      }

      .creature-section-grid {
        display: grid;
        gap: 0.75rem;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }

      .creature-section-grid--compact {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }

      .creature-section-grid--full {
        grid-template-columns: minmax(0, 1fr);
      }

      .creature-section-grid textarea {
        min-height: 90px;
      }

      .creature-export-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
      }

      .creature-selection-count {
        font-size: 0.9rem;
        color: var(--ink-muted);
      }

      /* Stat card print layout uses fixed card sizing for 63mm x 88mm prints. */
      .stat-card {
        width: 63mm;
        height: 88mm;
        padding: 4mm;
        box-sizing: border-box;
        border: 1px solid #3b2f21;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 2mm;
        font-family: var(--sans);
        color: #14100c;
        background: linear-gradient(165deg, #fff7e8 0%, #f1e1c2 100%);
        box-shadow: 0 3mm 5mm rgba(20, 14, 8, 0.25);
        position: relative;
        overflow: hidden;
      }

      .stat-card__header {
        border-bottom: 1px solid rgba(59, 47, 33, 0.7);
        padding-bottom: 1mm;
        display: grid;
        gap: 0.8mm;
      }

      .stat-card__name {
        font-weight: 700;
        font-size: 11pt;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      .stat-card__meta {
        font-size: 8.5pt;
        color: #4c3d2a;
      }

      .stat-card__body {
        display: grid;
        gap: 1mm;
        font-size: 8pt;
        line-height: 1.2;
        text-wrap: pretty;
      }

      .stat-card__line--title {
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        margin-top: 0.6mm;
      }

      .stat-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4mm;
        background: linear-gradient(90deg, #7a1414 0%, #c9a24a 100%);
        opacity: 0.9;
      }

      .stat-card__header,
      .stat-card__body {
        position: relative;
        z-index: 1;
      }

      .npc-progress {
        background: rgba(20, 16, 12, 0.7);
        border-radius: 999px;
        height: 10px;
        overflow: hidden;
        margin-bottom: 1.2rem;
        border: 1px solid rgba(201, 162, 74, 0.4);
      }

      .npc-progress__bar {
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, rgba(201, 162, 74, 0.5), var(--gold-bright));
        transition: width 0.3s ease;
      }

      .npc-step {
        display: none;
      }

      .npc-step.is-active {
        display: block;
      }

      .npc-step__header {
        margin-bottom: 0.6rem;
      }

      .npc-step__title {
        font-family: var(--serif);
        color: var(--gold-bright);
        margin-bottom: 0.25rem;
      }

      .initiative-tracker {
        margin: 0.9rem 0 0;
        background: rgba(28, 22, 16, 0.92);
        border-radius: 16px;
        padding: 1.1rem;
        border: 1px solid rgba(201, 162, 74, 0.6);
        box-shadow: 0 14px 22px var(--shadow);
      }

      .initiative-tracker h2 {
        font-family: var(--serif);
        margin-bottom: 0.4rem;
      }

      /* Two-panel tracker layout: encounter drawer on the left, tracker on the right. */
      .tracker-layout {
        --drawer-width-expanded: 380px;
        --drawer-width-collapsed: 3.5rem;
        display: grid;
        grid-template-columns: minmax(0, var(--drawer-width-expanded)) minmax(0, 1fr);
        gap: 1.1rem;
        margin-top: 0.8rem;
        align-items: start;
      }

      /* When encounter tools are hidden, allow the tracker to span the full width. */
      .tracker-layout.is-collapsed {
        grid-template-columns: var(--drawer-width-collapsed) minmax(0, 1fr);
      }

      /* Encounter library sidebar gives the GM quick access to saved encounters. */
      .encounter-library {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
      }

      .encounter-list {
        list-style: none;
        display: grid;
        gap: 0.6rem;
      }

      .encounter-entry {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 0.45rem;
        padding: 0.55rem 0.7rem;
        border-radius: 12px;
        background: rgba(20, 16, 12, 0.92);
        border: 1px solid rgba(201, 162, 74, 0.35);
      }

      .encounter-entry.is-active {
        border-color: var(--gold-bright);
        box-shadow: 0 0 0 1px rgba(232, 200, 119, 0.25);
      }

      .encounter-entry-title {
        font-weight: 600;
        color: var(--ink);
      }

      .encounter-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .encounter-action {
        background: transparent;
        border: 1px dashed rgba(201, 162, 74, 0.7);
        color: var(--gold-bright);
        padding: 0.35rem 0.55rem;
        border-radius: 10px;
        cursor: pointer;
        font-size: 0.85rem;
      }

      .encounter-empty {
        color: var(--ink-muted);
        font-size: 0.88rem;
        padding: 0.5rem 0;
      }

      .tracker-panel {
        background: rgba(36, 28, 20, 0.96);
        border-radius: 14px;
        padding: 1rem;
        border: 1px solid rgba(201, 162, 74, 0.35);
      }

      .tracker-panel h3 {
        font-family: var(--serif);
        margin-bottom: 0.8rem;
      }

      /* Support nested panel headings for grouped encounter content. */
      .tracker-panel h4,
      .tracker-panel h5 {
        font-family: var(--serif);
        margin-bottom: 0.6rem;
        color: var(--gold-bright);
      }

      /* Sliding encounter drawer keeps encounter setup and library grouped together. */
      .encounter-drawer {
        position: relative;
        overflow: hidden;
        width: var(--drawer-width-expanded);
        min-height: 100%;
        transition: width 0.35s ease;
      }

      /* Drawer card gives a modal-like shell to connect library and setup content. */
      .encounter-drawer__card {
        background: rgba(42, 32, 24, 0.98);
        border-radius: 18px;
        border: 1px solid rgba(201, 162, 74, 0.6);
        box-shadow: 0 18px 28px var(--shadow);
        overflow: hidden;
        transition: transform 0.35s ease;
      }

      /* Drawer header keeps the label anchored to the container. */
      .encounter-drawer__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.8rem;
        padding: 0.9rem 1rem;
        background: linear-gradient(90deg, rgba(60, 45, 33, 0.95), rgba(38, 29, 21, 0.95));
        border-bottom: 1px solid rgba(201, 162, 74, 0.4);
      }

      .encounter-drawer__header-title {
        font-family: var(--serif);
        font-size: 1rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--gold-bright);
      }

      /* Drawer toggle is integrated into the header for a unified surface. */
      .encounter-drawer__toggle {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 2.4rem;
        height: 2.4rem;
        border-radius: 12px;
        background: rgba(201, 162, 74, 0.18);
        border: 1px solid rgba(201, 162, 74, 0.6);
        color: var(--gold-bright);
        font-weight: 700;
        transition: transform 0.3s ease, box-shadow 0.2s ease;
      }

      .encounter-drawer__toggle:hover,
      .encounter-drawer__toggle:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 10px 18px var(--shadow);
        outline: none;
      }

      .encounter-drawer__toggle-icon {
        display: inline-flex;
        font-size: 1rem;
        transition: transform 0.3s ease;
      }

      .tracker-layout.is-collapsed .encounter-drawer__toggle-icon {
        transform: rotate(180deg);
      }

      /* Drawer body keeps the grouped panels inside the modal-like container. */
      .encounter-drawer__body {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1rem;
        background: rgba(32, 24, 17, 0.92);
      }

      /* Drawer content slides to create a side-tray animation. */
      .encounter-side-panel {
        display: flex;
        flex-direction: column;
        gap: 1.1rem;
        width: var(--drawer-width-expanded);
      }

      /* Collapsed handle preserves a label and control when the drawer is hidden. */
      .encounter-drawer__collapsed-handle {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 0.65rem;
        width: var(--drawer-width-collapsed);
        margin-left: auto;
        background: linear-gradient(180deg, rgba(63, 44, 28, 0.95), rgba(32, 22, 14, 0.95));
        border-left: 1px solid rgba(201, 162, 74, 0.45);
        box-shadow: inset 0 0 18px rgba(0, 0, 0, 0.35);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease;
      }

      .encounter-drawer__collapsed-toggle {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 2.2rem;
        height: 2.2rem;
        border-radius: 12px;
        background: rgba(201, 162, 74, 0.18);
        border: 1px solid rgba(201, 162, 74, 0.6);
        color: var(--gold-bright);
        font-weight: 700;
        transition: transform 0.3s ease, box-shadow 0.2s ease;
      }

      .encounter-drawer__collapsed-toggle:hover,
      .encounter-drawer__collapsed-toggle:focus-visible {
        transform: translateY(-2px);
        box-shadow: 0 10px 18px var(--shadow);
        outline: none;
      }

      .encounter-drawer__collapsed-text {
        font-family: var(--serif);
        font-size: 0.85rem;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: var(--gold-bright);
        writing-mode: vertical-rl;
        text-orientation: mixed;
      }

      /* Collapsed state shifts the card out of view while exposing the label. */
      .tracker-layout.is-collapsed .encounter-drawer {
        width: var(--drawer-width-collapsed);
      }

      .tracker-layout.is-collapsed .encounter-drawer__card {
        transform: translateX(calc(-1 * (var(--drawer-width-expanded) - var(--drawer-width-collapsed))));
      }

      .tracker-layout.is-collapsed .encounter-drawer__collapsed-handle {
        opacity: 1;
        pointer-events: auto;
      }

      /* Main tracker panel stacks round controls and initiative list. */
      .tracker-main {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .field-row {
        display: grid;
        gap: 0.6rem;
        grid-template-columns: minmax(0, 1fr) 140px 150px 110px;
        align-items: end;
      }

      /* Encounter management rows resize for longer inputs and actions. */
      .field-row--encounter-name {
        grid-template-columns: minmax(0, 1fr);
        align-items: center;
      }

      /* Participant setup splits name from type controls for clearer scanning. */
      .field-row--participant-name {
        grid-template-columns: minmax(0, 1fr);
      }

      /* Second line keeps type, CR, and add action grouped together. */
      .field-row--participant-meta {
        /* Use two columns so we can stack the type field on its own row when space is tight. */
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      /* Full-width select avoids the type field being squeezed or clipped in narrow drawers. */
      .participant-type-field {
        grid-column: 1 / -1;
      }

      /* Ensure the add button aligns with the bottom of the row controls. */
      .participant-action {
        align-self: end;
        justify-self: end;
      }

      .encounter-manager {
        /* Keep the encounter name area clean and unboxed for clarity. */
        background: transparent;
        border: none;
        padding: 0;
        margin-bottom: 0.9rem;
      }

      .encounter-manager h5 {
        font-family: var(--serif);
        margin-bottom: 0.6rem;
        color: var(--gold-bright);
      }

      label {
        font-weight: 600;
      }

      input,
      select,
      button,
      textarea {
        font-family: inherit;
        font-size: 0.95rem;
      }

      input,
      select,
      textarea {
        width: 100%;
        padding: 0.45rem 0.55rem;
        border-radius: 10px;
        border: 1px solid rgba(201, 162, 74, 0.45);
        background: rgba(20, 16, 12, 0.9);
        color: var(--ink);
      }

      button {
        border: none;
        border-radius: 10px;
        padding: 0.6rem 1rem;
        cursor: pointer;
        background: var(--crimson);
        color: #fff;
        font-weight: 600;
        transition: transform 0.1s ease, box-shadow 0.2s ease;
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 16px var(--shadow);
      }

      button.secondary {
        background: rgba(201, 162, 74, 0.18);
        color: var(--ink);
        border: 1px solid rgba(201, 162, 74, 0.5);
      }

      button.ghost {
        background: transparent;
        border: 1px dashed rgba(201, 162, 74, 0.7);
        color: var(--gold-bright);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
      }

      .participant-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.92rem;
      }

      .participant-table th,
      .participant-table td {
        padding: 0.45rem 0.4rem;
        border-bottom: 1px solid rgba(201, 162, 74, 0.35);
        text-align: left;
        vertical-align: top;
      }

      .participant-table th {
        font-family: var(--serif);
      }

      .participant-row.active {
        background: rgba(176, 42, 42, 0.2);
        border-left: 4px solid var(--crimson);
      }

      .marker-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        margin-top: 0.4rem;
      }

      .marker-chip {
        background: rgba(201, 162, 74, 0.15);
        border: 1px solid rgba(201, 162, 74, 0.45);
        padding: 0.25rem 0.45rem;
        border-radius: 999px;
        display: inline-flex;
        gap: 0.35rem;
        align-items: center;
        font-size: 0.82rem;
      }

      .marker-chip button {
        background: transparent;
        border: none;
        color: var(--crimson);
        padding: 0;
        font-size: 0.9rem;
      }

      .initiative-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.8rem;
        margin-top: 1rem;
        align-items: center;
      }

      .round-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
      }

      .round-controls .initiative-controls {
        margin-top: 0;
      }

      .status-pill {
        background: rgba(107, 179, 111, 0.2);
        color: var(--success);
        padding: 0.3rem 0.6rem;
        border-radius: 999px;
        font-size: 0.85rem;
        border: 1px solid rgba(107, 179, 111, 0.4);
      }

      .round-display {
        font-weight: 700;
        color: var(--gold-bright);
      }

      .helper-text {
        font-size: 0.85rem;
        color: var(--ink-muted);
      }

      .legend {
        display: flex;
        gap: 0.6rem;
        flex-wrap: wrap;
        margin-top: 0.6rem;
      }

      .legend span {
        background: rgba(201, 162, 74, 0.2);
        border-radius: 999px;
        padding: 0.2rem 0.6rem;
        font-size: 0.78rem;
      }

      /* Modal (lightbox) styling */
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(22, 16, 11, 0.55);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 1.5rem;
      }

      .modal-overlay.active {
        display: flex;
      }

      .modal {
        background: rgba(33, 25, 18, 0.98);
        border-radius: 18px;
        padding: 1.6rem;
        max-width: 720px;
        width: 100%;
        box-shadow: 0 20px 40px var(--shadow);
        border: 2px solid var(--gold);
      }

      .modal h3 {
        font-family: var(--serif);
        margin-bottom: 0.6rem;
      }

      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.6rem;
        margin-top: 1rem;
        flex-wrap: wrap;
      }

      .modal-list {
        display: grid;
        gap: 0.8rem;
        max-height: 340px;
        overflow: auto;
        padding-right: 0.4rem;
      }

      .modal-item {
        display: grid;
        grid-template-columns: minmax(0, 1fr) 120px;
        gap: 0.8rem;
        align-items: center;
        padding: 0.5rem 0.7rem;
        border-radius: 12px;
        border: 1px solid rgba(201, 162, 74, 0.4);
        background: rgba(20, 16, 12, 0.9);
      }

      .notice {
        background: rgba(227, 160, 66, 0.18);
        border-left: 4px solid var(--warning);
        padding: 0.6rem 0.8rem;
        border-radius: 10px;
        margin-top: 0.6rem;
        font-size: 0.88rem;
      }

      .tracker-footer {
        display: grid;
        gap: 0.8rem;
        margin-top: 1rem;
      }

      .tracker-summary {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        font-weight: 600;
      }

      .is-hidden {
        display: none;
      }

      /* Footer for thematic close */
      footer {
        background: var(--crimson-dark);
        color: var(--ink);
        padding: 0.6rem 0;
        text-align: center;
        font-size: 0.9rem;
      }

      @media (max-width: 920px) {
        .dashboard-grid {
          grid-template-columns: 1fr;
        }

        .tracker-layout {
          grid-template-columns: 1fr;
        }

        .npc-layout {
          grid-template-columns: 1fr;
        }

        .session-layout {
          grid-template-columns: 1fr;
        }

        .field-row {
          grid-template-columns: 1fr;
        }

        .modal-item {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <!-- Minimal header shared across views for consistent context. -->
    <header class="app-header">
      <div class="container header-frame">
        <p class="header-title">Pathfinder Game Master Toolkit</p>
        <h1 class="header-module" id="active-module">Current Campaign Plan</h1>
        <p class="header-description" id="module-description">
          Review upcoming sessions, prep priorities, and launch tools as needed from one planning workspace.
        </p>
      </div>
    </header>

    <!-- Planning-focused home view keeps campaign context visible before opening modules. -->
    <main class="dashboard-main" id="dashboard-view">
      <div class="container dashboard-grid">
        <section aria-label="Campaign planning workspace" class="planning-layout">
          <h2 class="section-title">Current Campaign Plan</h2>
          <article class="planning-card" aria-label="Campaign launch actions">
            <h3>Session Launch Actions</h3>
            <p>Start from your plan, then jump into active tracking or prep with one click.</p>
            <div class="planning-actions">
              <button class="primary-action" type="button" id="start-session-action">Start Session</button>
              <button class="primary-action" type="button" id="continue-prep-action">Continue Prep</button>
            </div>
          </article>

          <article class="planning-card" aria-label="Upcoming sessions">
            <h3>Upcoming Sessions</h3>
            <ul class="planning-list">
              <li><strong>Session 18:</strong> Siege of Emberwatch (Tomorrow, 7:30 PM)</li>
              <li><strong>Session 19:</strong> Cultist Interrogation (Sat, May 18)</li>
            </ul>
          </article>

          <article class="planning-card" aria-label="Open prep tasks">
            <h3>Open Prep Tasks</h3>
            <ul class="planning-list">
              <li>Finalize rooftop chase hazard DCs for Emberwatch alleys.</li>
              <li>Prepare social clues for Captain Vale's informant scene.</li>
              <li>Confirm fallback encounter if players skip the crypt route.</li>
            </ul>
          </article>

          <article class="planning-card" aria-label="Linked campaign assets">
            <h3>Linked Encounters, NPCs, and Creatures</h3>
            <ul class="planning-list">
              <li><strong>Encounter:</strong> Emberwatch Gate Ambush (Moderate 6)</li>
              <li><strong>NPC:</strong> Captain Vale (Ally, City Watch)</li>
              <li><strong>Creature:</strong> Ash Warden Drake (Level 7 skirmisher)</li>
            </ul>
          </article>

          <article class="planning-card" aria-label="Secondary tool modules">
            <h3>Tool Modules (Secondary)</h3>
            <p>Open focused tool panels from the planning workspace as needed.</p>
            <div class="planning-tool-tabs" role="tablist" aria-label="Planning workspace tools">
              <button class="secondary-tab" type="button" id="initiative-launch" aria-label="Open Initiative Tracker module">
                Initiative Tracker
              </button>
              <button class="secondary-tab" type="button" id="session-launch" aria-label="Open Session Notes module">
                Session Notes
              </button>
              <button class="secondary-tab" type="button" id="npc-launch" aria-label="Open NPC Vault module">
                NPC Vault
              </button>
              <button class="secondary-tab" type="button" id="creature-launch" aria-label="Open Creature Library module">
                Creature Library
              </button>
            </div>
          </article>

          <article class="planning-card planning-card--planned" aria-label="Planned module">
            <h3>Treasure Generator</h3>
            <p>Loot workflow is planned but not yet implemented as a launchable module.</p>
            <span class="planned-note">Planned module · no launch action yet</span>
          </article>
        </section>

        <!-- Right column panels for spotlight info -->
        <aside aria-label="GM status panels">
          <div class="side-panel">
            <h2>Active Threads</h2>
            <ul class="panel-list">
              <li class="panel-item">Resolve the midnight heist before sunrise.</li>
              <li class="panel-item">Track the cult envoy meeting on Day 3.</li>
              <li class="panel-item">Reveal the vault guardian's true motive.</li>
            </ul>
          </div>
          <div class="side-panel">
            <h2>Recent Updates</h2>
            <ul class="panel-list">
              <li class="panel-item">NPC "Captain Vale" promoted to ally status.</li>
              <li class="panel-item">Added 2 new traps to encounter library.</li>
              <li class="panel-item">Session recap shared with players.</li>
            </ul>
          </div>
        </aside>
      </div>
    </main>

    <!-- Initiative tracker module (opens from the dashboard tool card) -->
    <section
      class="initiative-module is-hidden"
      id="initiative-module"
      aria-label="Initiative tracker module"
    >
      <div class="container">
        <!-- Module actions stay in the body so the header stays minimal. -->
        <div class="module-actions">
          <button id="initiative-back" class="ghost" type="button">
            ← Back to Dashboard
          </button>
        </div>

        <section class="initiative-tracker" aria-label="Initiative tracker workspace">
          <p class="helper-text">
            Set up your encounter roster, gather initiative rolls in a lightbox prompt, and manage
            round-by-round conditions with automatic expiry reminders.
          </p>
          <div class="tracker-layout is-collapsed" id="tracker-layout">
            <aside class="encounter-drawer" id="encounter-side-panel" aria-label="Encounter setup and library">
              <!-- Drawer card keeps encounter library and setup unified as a single container. -->
              <div class="encounter-drawer__card encounter-side-panel" id="encounter-panel-content">
                <header class="encounter-drawer__header">
                  <h3 class="encounter-drawer__header-title">Encounter Library</h3>
                  <button
                    id="encounter-panel-toggle"
                    class="encounter-drawer__toggle"
                    type="button"
                    aria-expanded="false"
                    aria-controls="encounter-panel-content"
                    aria-label="Expand Encounter Library"
                  >
                    <span class="encounter-drawer__toggle-icon" aria-hidden="true">▸</span>
                  </button>
                </header>
                <div class="encounter-drawer__body">
                  <div class="tracker-panel encounter-library">
                    <h4>Library</h4>
                    <p class="helper-text">
                      Create a new encounter or load a saved roster into the tracker.
                    </p>
                    <button id="create-encounter" type="button">Create New Encounter</button>
                    <ul id="encounter-list" class="encounter-list" aria-label="Saved encounters"></ul>
                  </div>
                  <div class="tracker-panel">
                    <h4>Setup</h4>
                    <div class="encounter-manager">
                      <!-- Encounter name stays visible without a boxed treatment. -->
                      <h5>Encounter Name</h5>
                      <div class="field-row field-row--encounter-name">
                        <div>
                          <label for="encounter-name">Encounter name</label>
                          <input
                            id="encounter-name"
                            name="encounter-name"
                            type="text"
                            placeholder="e.g. Crimson Guard Ambush"
                          />
                        </div>
                      </div>
                      <p class="helper-text" id="encounter-status-note">
                        Build multiple encounters and save them to browser memory for quick swaps.
                      </p>
                    </div>
                    <form id="participant-form">
                      <!-- Keep participant name on its own line for quick identification. -->
                      <div class="field-row field-row--participant-name">
                        <div>
                          <label for="participant-name">Participant name</label>
                          <input
                            id="participant-name"
                            name="participant-name"
                            type="text"
                            placeholder="e.g. Sir Garrick"
                            required
                          />
                        </div>
                      </div>
                      <!-- Group participant type and CR on a separate line for clarity. -->
                      <div class="field-row field-row--participant-meta">
                        <!-- Full-width type field keeps the selector readable. -->
                        <div class="participant-type-field">
                          <label for="participant-type">Type</label>
                          <select id="participant-type" name="participant-type">
                            <option value="Player">Player</option>
                            <option value="NPC">NPC</option>
                            <option value="Monster">Monster</option>
                          </select>
                        </div>
                        <div id="participant-cr-field" class="is-hidden">
                          <label for="participant-cr">CR (XP)</label>
                          <select id="participant-cr" name="participant-cr"></select>
                        </div>
                        <!-- Align add action to the bottom-right for quick scanning. -->
                        <div class="participant-action">
                          <button type="submit">Add</button>
                        </div>
                      </div>
                    </form>
                    <div class="initiative-controls">
                      <button id="save-encounter" class="secondary" type="button">Save / Update</button>
                    </div>
                  </div>
                </div>
              </div>
              <!-- Collapsed handle preserves access to the drawer when the panel is hidden. -->
              <div class="encounter-drawer__collapsed-handle" id="encounter-panel-collapsed-handle">
                <button
                  id="encounter-panel-toggle-collapsed"
                  class="encounter-drawer__collapsed-toggle"
                  type="button"
                  aria-expanded="false"
                  aria-controls="encounter-panel-content"
                  aria-label="Expand Encounter Library"
                >
                  <span aria-hidden="true">▸</span>
                </button>
                <span class="encounter-drawer__collapsed-text">Encounters</span>
              </div>
            </aside>

            <div class="tracker-main">
              <div class="tracker-panel round-controls">
                <h3>Round Controls</h3>
                <p>
                  <span class="round-display">Round:</span>
                  <span id="round-count">1</span>
                </p>
                <p>
                  <strong>Current:</strong>
                  <span id="current-participant">Awaiting initiative...</span>
                </p>
                <div class="initiative-controls">
                  <button id="previous-turn" class="ghost" disabled>Previous Turn</button>
                  <button id="next-turn" disabled>Next Turn</button>
                  <span id="encounter-status" class="status-pill is-hidden">Encounter Active</span>
                </div>
              </div>

              <div class="tracker-panel">
                <h3>Tracker</h3>
                <table class="participant-table" aria-label="Initiative order">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Initiative</th>
                      <th>Markers</th>
                      <th>Actions</th>
                      <th>CR (XP)</th>
                    </tr>
                  </thead>
                  <tbody id="participant-body">
                    <tr>
                      <td colspan="6" class="helper-text">Add participants to begin building the encounter.</td>
                    </tr>
                  </tbody>
                </table>
                <div class="tracker-footer">
                  <div class="tracker-summary">
                    <span>Encounter CR: <span id="encounter-cr">—</span></span>
                    <span>Total XP: <span id="total-xp">0</span></span>
                    <span>XP per player: <span id="xp-per-player">0</span></span>
                  </div>
                  <div class="initiative-controls">
                    <button id="start-encounter" class="secondary" disabled>Begin Encounter</button>
                    <button id="reward-encounter" class="ghost" disabled>Mark Rewards Given</button>
                    <span id="reward-status" class="status-pill is-hidden">Rewards Granted</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>
      </div>
    </section>

    <!-- NPC creation wizard lightbox -->
    <div id="npc-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal modal--wide">
        <div class="npc-modal-header">
          <div>
            <h3 id="npc-modal-title">Create NPC</h3>
            <p id="npc-modal-step" class="helper-text">Step 1 of 6: Identity & Role</p>
          </div>
          <button id="npc-modal-close" class="ghost" type="button">Close</button>
        </div>
        <div
          class="npc-progress"
          role="progressbar"
          aria-valuemin="1"
          aria-valuemax="6"
          aria-valuenow="1"
        >
          <div class="npc-progress__bar" id="npc-progress-bar"></div>
        </div>
        <form id="npc-form">
          <!-- Step 1: Identity & Role -->
          <section class="npc-step is-active" data-step="1" data-title="Identity & Role">
            <div class="npc-step__header">
              <h4 class="npc-step__title">Identity & Role</h4>
              <p class="helper-text">Capture the quick reference details used during play.</p>
            </div>
            <div class="npc-section-grid">
              <div>
                <label for="npc-name">Name</label>
                <input
                  id="npc-name"
                  name="npc-name"
                  type="text"
                  placeholder="e.g. Captain Vale"
                  required
                />
              </div>
              <div>
                <label for="npc-role">Role</label>
                <input
                  id="npc-role"
                  name="npc-role"
                  type="text"
                  placeholder="e.g. Harbor Master"
                />
              </div>
              <div>
                <label for="npc-faction">Faction</label>
                <input
                  id="npc-faction"
                  name="npc-faction"
                  type="text"
                  placeholder="e.g. Crimson Fleet"
                />
              </div>
              <div>
                <label for="npc-location">Location</label>
                <input
                  id="npc-location"
                  name="npc-location"
                  type="text"
                  placeholder="e.g. Dockside"
                />
              </div>
              <div>
                <label for="npc-tags">Tags (comma-separated)</label>
                <input
                  id="npc-tags"
                  name="npc-tags"
                  type="text"
                  placeholder="e.g. smuggler, swordmaster"
                />
              </div>
            </div>
          </section>

          <!-- Step 2: Background & Demeanor -->
          <section class="npc-step" data-step="2" data-title="Background & Demeanor">
            <div class="npc-step__header">
              <h4 class="npc-step__title">Background & Demeanor</h4>
              <p class="helper-text">Define lineage, role, and how the NPC engages the party.</p>
            </div>
            <div class="npc-section-grid">
              <div>
                <label for="npc-ancestry">Ancestry</label>
                <input
                  id="npc-ancestry"
                  name="npc-ancestry"
                  type="text"
                  placeholder="e.g. Human"
                />
              </div>
              <div>
                <label for="npc-class">Class</label>
                <input
                  id="npc-class"
                  name="npc-class"
                  type="text"
                  placeholder="e.g. Fighter"
                />
              </div>
              <div>
                <label for="npc-level">Level</label>
                <input
                  id="npc-level"
                  name="npc-level"
                  type="number"
                  min="0"
                  step="1"
                  placeholder="e.g. 4"
                />
              </div>
              <div>
                <label for="npc-alignment">Alignment</label>
                <input
                  id="npc-alignment"
                  name="npc-alignment"
                  type="text"
                  placeholder="e.g. Lawful Neutral"
                />
              </div>
              <div>
                <label for="npc-size">Size</label>
                <select id="npc-size" name="npc-size">
                  <option value="Tiny">Tiny</option>
                  <option value="Small">Small</option>
                  <option value="Medium" selected>Medium</option>
                  <option value="Large">Large</option>
                  <option value="Huge">Huge</option>
                  <option value="Gargantuan">Gargantuan</option>
                </select>
              </div>
              <div>
                <label for="npc-disposition">Disposition</label>
                <select id="npc-disposition" name="npc-disposition">
                  <option value="Friendly">Friendly</option>
                  <option value="Neutral">Neutral</option>
                  <option value="Wary">Wary</option>
                  <option value="Hostile">Hostile</option>
                </select>
              </div>
              <div>
                <label for="npc-relationship">Relationship</label>
                <select id="npc-relationship" name="npc-relationship">
                  <option value="Ally">Ally</option>
                  <option value="Contact">Contact</option>
                  <option value="Neutral" selected>Neutral</option>
                  <option value="Rival">Rival</option>
                  <option value="Enemy">Enemy</option>
                </select>
              </div>
            </div>
          </section>

          <!-- Step 3: Combat Snapshot -->
          <section class="npc-step" data-step="3" data-title="Combat Snapshot">
            <div class="npc-step__header">
              <h4 class="npc-step__title">Combat Snapshot</h4>
              <p class="helper-text">Summarize the numbers you reference during encounters.</p>
            </div>
            <div class="npc-section-grid">
              <div>
                <label for="npc-hp">Hit Points</label>
                <input
                  id="npc-hp"
                  name="npc-hp"
                  type="number"
                  min="0"
                  step="1"
                  placeholder="e.g. 44"
                />
              </div>
              <div>
                <label for="npc-ac">Armor Class</label>
                <input
                  id="npc-ac"
                  name="npc-ac"
                  type="number"
                  min="0"
                  step="1"
                  placeholder="e.g. 19"
                />
              </div>
              <div>
                <label for="npc-speed">Speed</label>
                <input
                  id="npc-speed"
                  name="npc-speed"
                  type="text"
                  placeholder="e.g. 25 ft."
                />
              </div>
              <div>
                <label for="npc-initiative">Initiative</label>
                <input
                  id="npc-initiative"
                  name="npc-initiative"
                  type="number"
                  step="1"
                  placeholder="e.g. +7"
                />
              </div>
            </div>
          </section>

          <!-- Step 4: Ability Scores -->
          <section class="npc-step" data-step="4" data-title="Ability Scores">
            <div class="npc-step__header">
              <h4 class="npc-step__title">Ability Scores</h4>
              <p class="helper-text">Record the core stats that influence checks and saves.</p>
            </div>
            <div class="npc-section-grid npc-section-grid--compact">
              <div>
                <label for="npc-str">STR</label>
                <input id="npc-str" name="npc-str" type="number" step="1" placeholder="e.g. 16" />
              </div>
              <div>
                <label for="npc-dex">DEX</label>
                <input id="npc-dex" name="npc-dex" type="number" step="1" placeholder="e.g. 14" />
              </div>
              <div>
                <label for="npc-con">CON</label>
                <input id="npc-con" name="npc-con" type="number" step="1" placeholder="e.g. 12" />
              </div>
              <div>
                <label for="npc-int">INT</label>
                <input id="npc-int" name="npc-int" type="number" step="1" placeholder="e.g. 10" />
              </div>
              <div>
                <label for="npc-wis">WIS</label>
                <input id="npc-wis" name="npc-wis" type="number" step="1" placeholder="e.g. 13" />
              </div>
              <div>
                <label for="npc-cha">CHA</label>
                <input id="npc-cha" name="npc-cha" type="number" step="1" placeholder="e.g. 8" />
              </div>
            </div>
          </section>

          <!-- Step 5: Defenses & Senses -->
          <section class="npc-step" data-step="5" data-title="Defenses & Senses">
            <div class="npc-step__header">
              <h4 class="npc-step__title">Defenses & Senses</h4>
              <p class="helper-text">Track saving throws, senses, and language notes.</p>
            </div>
            <div class="npc-section-grid">
              <div>
                <label for="npc-fortitude">Fortitude</label>
                <input
                  id="npc-fortitude"
                  name="npc-fortitude"
                  type="number"
                  step="1"
                  placeholder="e.g. +9"
                />
              </div>
              <div>
                <label for="npc-reflex">Reflex</label>
                <input
                  id="npc-reflex"
                  name="npc-reflex"
                  type="number"
                  step="1"
                  placeholder="e.g. +6"
                />
              </div>
              <div>
                <label for="npc-will">Will</label>
                <input
                  id="npc-will"
                  name="npc-will"
                  type="number"
                  step="1"
                  placeholder="e.g. +5"
                />
              </div>
              <div>
                <label for="npc-senses">Senses</label>
                <input
                  id="npc-senses"
                  name="npc-senses"
                  type="text"
                  placeholder="e.g. darkvision 60 ft."
                />
              </div>
              <div>
                <label for="npc-languages">Languages</label>
                <input
                  id="npc-languages"
                  name="npc-languages"
                  type="text"
                  placeholder="e.g. Common, Dwarven"
                />
              </div>
            </div>
          </section>

          <!-- Step 6: Story Hooks & Notes -->
          <section class="npc-step" data-step="6" data-title="Story Hooks & Notes">
            <div class="npc-step__header">
              <h4 class="npc-step__title">Story Hooks & Notes</h4>
              <p class="helper-text">Add equipment, abilities, and roleplay cues for fast recall.</p>
            </div>
            <div class="npc-section-grid npc-section-grid--full">
              <div>
                <label for="npc-hook">Story hook</label>
                <textarea
                  id="npc-hook"
                  name="npc-hook"
                  placeholder="e.g. Wants the party to recover a lost logbook."
                ></textarea>
              </div>
              <div>
                <label for="npc-skills">Skills & Proficiencies</label>
                <textarea
                  id="npc-skills"
                  name="npc-skills"
                  placeholder="e.g. Athletics +8, Intimidation +7, Sailing lore +6."
                ></textarea>
              </div>
              <div>
                <label for="npc-equipment">Equipment</label>
                <textarea
                  id="npc-equipment"
                  name="npc-equipment"
                  placeholder="e.g. Boarding axe, breastplate, signal whistle."
                ></textarea>
              </div>
              <div>
                <label for="npc-abilities">Special Abilities</label>
                <textarea
                  id="npc-abilities"
                  name="npc-abilities"
                  placeholder="e.g. Harpoon Strike, Commanding Presence."
                ></textarea>
              </div>
              <div>
                <label for="npc-notes">Roleplay notes</label>
                <textarea
                  id="npc-notes"
                  name="npc-notes"
                  placeholder="e.g. Speaks in clipped sentences, always taps a brass ring."
                ></textarea>
              </div>
            </div>
          </section>

          <div class="modal-actions">
            <button id="npc-step-back" class="ghost" type="button">Back</button>
            <button id="npc-step-next" type="button">Next</button>
            <button id="npc-submit" type="submit">Create NPC</button>
            <button id="npc-reset" class="secondary" type="button">Reset</button>
          </div>
        </form>
        <p class="helper-text" id="npc-form-note">
          Use the gallery to revisit NPCs and update their relationship status.
        </p>
      </div>
    </div>

    <!-- NPC vault module (opens from the dashboard tool card) -->
    <section class="npc-module is-hidden" id="npc-module" aria-label="NPC vault module">
      <div class="container">
        <!-- Module actions stay in the body so the header stays minimal. -->
        <div class="module-actions">
          <button id="npc-back" class="ghost" type="button">
            ← Back to Dashboard
          </button>
          <button id="npc-create" type="button">Create New</button>
        </div>

        <section class="npc-vault" aria-label="NPC vault workspace">
          <p class="helper-text">
            Build NPC snapshots, capture roleplay notes, and keep relationship cues ready for play.
          </p>
          <div class="npc-layout">
            <div class="npc-column">
              <div class="tracker-panel npc-list-panel">
                <div class="npc-gallery-panel__header">
                  <div>
                    <h3>NPC Gallery</h3>
                    <p class="helper-text">
                      Select a card to review details or open the wizard to add a new profile.
                    </p>
                  </div>
                  <div class="npc-gallery-panel__actions">
                    <button id="npc-create-inline" class="secondary" type="button">Create New</button>
                  </div>
                </div>
                <div id="npc-list" class="npc-gallery-grid" aria-label="Saved NPCs"></div>
                <p class="helper-text" id="npc-empty-state">
                  No NPCs saved yet. Create a new profile to start your gallery.
                </p>
              </div>
            </div>

            <aside class="tracker-panel npc-detail-panel" aria-label="Active NPC details">
              <h3>Active NPC</h3>
              <div id="npc-detail" class="npc-detail">
                <p class="helper-text">Select an NPC to see their details here.</p>
              </div>
              <div class="npc-detail-actions">
                <button class="secondary" type="button" data-npc-status="Ally">Promote to Ally</button>
                <button class="ghost" type="button" data-npc-status="Contact">Mark as Contact</button>
                <button type="button" data-npc-status="Rival">Flag as Rival</button>
              </div>
            </aside>
          </div>
        </section>
      </div>
    </section>

    <!-- Creature library module (opens from the dashboard tool card) -->
    <section
      class="creature-module is-hidden"
      id="creature-module"
      aria-label="Creature library module"
    >
      <div class="container">
        <!-- Module actions stay in the body so the header stays minimal. -->
        <div class="module-actions">
          <button id="creature-back" class="ghost" type="button">
            ← Back to Dashboard
          </button>
          <button id="creature-new" type="button">Add Creature</button>
          <button id="creature-export" class="secondary" type="button">Export Selected to PDF</button>
        </div>

        <section class="creature-library" aria-label="Creature library workspace">
          <p class="helper-text">
            Build combat-ready creature cards, parse quick statblocks, and export printable decks
            for the table.
          </p>
          <div class="creature-layout">
            <div class="creature-column">
              <div class="tracker-panel creature-list-panel">
                <div class="npc-gallery-panel__header">
                  <div>
                    <h3>Creature Library</h3>
                    <p class="helper-text">
                      Select creatures for export or open an entry to edit combat stats.
                    </p>
                  </div>
                  <div class="npc-gallery-panel__actions">
                    <button id="creature-select-all" class="secondary" type="button">Select All</button>
                    <button id="creature-clear-selection" class="ghost" type="button">Clear</button>
                  </div>
                </div>
                <div id="creature-list" class="creature-list" aria-label="Saved creatures"></div>
                <p class="helper-text" id="creature-empty-state">
                  No creatures saved yet. Add a creature to start building your combat library.
                </p>
              </div>

              <div class="tracker-panel creature-export-panel" aria-label="Creature export options">
                <h3>Export Stat Cards</h3>
                <p class="helper-text">
                  Generate 63mm × 88mm cards with only combat essentials. Longer entries split into
                  multiple cards automatically.
                </p>
                <p class="creature-selection-count" id="creature-selection-count">
                  0 creatures selected.
                </p>
                <div class="creature-export-actions">
                  <button id="creature-export-selected" type="button">Export Selected to PDF</button>
                </div>
              </div>
            </div>

            <aside class="tracker-panel creature-form-panel" aria-label="Creature form">
              <h3 id="creature-form-title">Create Creature</h3>
              <form id="creature-form" class="creature-form">
                <div class="creature-form-sections">
                  <section class="creature-form-section">
                    <div class="creature-form-section__header">
                      <span class="creature-form-section__title">Quick Statblock Parser</span>
                      <span class="helper-text">
                        Paste a formatted statblock to prefill combat stats, then refine as needed.
                      </span>
                    </div>
                    <div class="creature-section-grid creature-section-grid--full">
                      <div>
                        <label for="creature-statblock">Statblock text</label>
                        <textarea
                          id="creature-statblock"
                          name="creature-statblock"
                          placeholder="Paste a creature statblock here."
                        ></textarea>
                      </div>
                    </div>
                    <div class="npc-form-actions">
                      <button id="creature-parse" class="secondary" type="button">Parse Statblock</button>
                      <button id="creature-clear-statblock" class="ghost" type="button">Clear</button>
                    </div>
                  </section>

                  <section class="creature-form-section">
                    <div class="creature-form-section__header">
                      <span class="creature-form-section__title">Creature Identity</span>
                      <span class="helper-text">Name, role, and quick descriptors for sorting.</span>
                    </div>
                    <div class="creature-section-grid">
                      <div>
                        <label for="creature-name">Creature name</label>
                        <input id="creature-name" name="creature-name" type="text" />
                      </div>
                      <div>
                        <label for="creature-level">Level / CR</label>
                        <input id="creature-level" name="creature-level" type="text" />
                      </div>
                      <div>
                        <label for="creature-role">Role</label>
                        <input id="creature-role" name="creature-role" type="text" />
                      </div>
                      <div>
                        <label for="creature-traits">Traits</label>
                        <input id="creature-traits" name="creature-traits" type="text" />
                      </div>
                      <div>
                        <label for="creature-alignment">Alignment</label>
                        <input id="creature-alignment" name="creature-alignment" type="text" />
                      </div>
                      <div>
                        <label for="creature-size">Size</label>
                        <input id="creature-size" name="creature-size" type="text" />
                      </div>
                      <div>
                        <label for="creature-perception">Perception</label>
                        <input id="creature-perception" name="creature-perception" type="text" />
                      </div>
                      <div>
                        <label for="creature-senses">Senses</label>
                        <input id="creature-senses" name="creature-senses" type="text" />
                      </div>
                      <div>
                        <label for="creature-languages">Languages</label>
                        <input id="creature-languages" name="creature-languages" type="text" />
                      </div>
                    </div>
                  </section>

                  <section class="creature-form-section">
                    <div class="creature-form-section__header">
                      <span class="creature-form-section__title">Defenses</span>
                      <span class="helper-text">Core stats for managing combat durability.</span>
                    </div>
                    <div class="creature-section-grid creature-section-grid--compact">
                      <div>
                        <label for="creature-ac">AC</label>
                        <input id="creature-ac" name="creature-ac" type="text" />
                      </div>
                      <div>
                        <label for="creature-hp">HP</label>
                        <input id="creature-hp" name="creature-hp" type="text" />
                      </div>
                      <div>
                        <label for="creature-fortitude">Fort</label>
                        <input id="creature-fortitude" name="creature-fortitude" type="text" />
                      </div>
                      <div>
                        <label for="creature-reflex">Ref</label>
                        <input id="creature-reflex" name="creature-reflex" type="text" />
                      </div>
                      <div>
                        <label for="creature-will">Will</label>
                        <input id="creature-will" name="creature-will" type="text" />
                      </div>
                      <div>
                        <label for="creature-resistances">Resistances</label>
                        <input id="creature-resistances" name="creature-resistances" type="text" />
                      </div>
                      <div>
                        <label for="creature-weaknesses">Weaknesses</label>
                        <input id="creature-weaknesses" name="creature-weaknesses" type="text" />
                      </div>
                      <div>
                        <label for="creature-immunities">Immunities</label>
                        <input id="creature-immunities" name="creature-immunities" type="text" />
                      </div>
                    </div>
                  </section>

                  <section class="creature-form-section">
                    <div class="creature-form-section__header">
                      <span class="creature-form-section__title">Offenses & Mobility</span>
                      <span class="helper-text">Movement speeds, strikes, and special actions.</span>
                    </div>
                    <div class="creature-section-grid">
                      <div>
                        <label for="creature-speed">Speed</label>
                        <input id="creature-speed" name="creature-speed" type="text" />
                      </div>
                      <div>
                        <label for="creature-melee">Melee</label>
                        <textarea id="creature-melee" name="creature-melee"></textarea>
                      </div>
                      <div>
                        <label for="creature-ranged">Ranged</label>
                        <textarea id="creature-ranged" name="creature-ranged"></textarea>
                      </div>
                      <div>
                        <label for="creature-abilities">Special abilities</label>
                        <textarea id="creature-abilities" name="creature-abilities"></textarea>
                      </div>
                    </div>
                  </section>

                  <section class="creature-form-section">
                    <div class="creature-form-section__header">
                      <span class="creature-form-section__title">Combat Notes</span>
                      <span class="helper-text">
                        Skills, tactics, and reminders needed during an encounter.
                      </span>
                    </div>
                    <div class="creature-section-grid">
                      <div>
                        <label for="creature-skills">Skills & modifiers</label>
                        <textarea id="creature-skills" name="creature-skills"></textarea>
                      </div>
                      <div>
                        <label for="creature-notes">Combat notes</label>
                        <textarea id="creature-notes" name="creature-notes"></textarea>
                      </div>
                    </div>
                  </section>
                </div>

                <div class="npc-form-actions">
                  <button id="creature-save" type="submit">Save Creature</button>
                  <button id="creature-reset" class="secondary" type="button">Reset Form</button>
                </div>
                <p class="helper-text" id="creature-form-note">
                  Keep entries focused on combat essentials; spellcasting can stay in campaign notes.
                </p>
              </form>
            </aside>
          </div>
        </section>
      </div>
    </section>

    <!-- Session notes module (opens from the dashboard tool card) -->
    <section class="session-module is-hidden" id="session-module" aria-label="Session notes module">
      <div class="container">
        <!-- Module actions stay in the body so the header stays minimal. -->
        <div class="module-actions">
          <button id="session-back" class="ghost" type="button">
            ← Back to Dashboard
          </button>
        </div>

        <section class="session-notes" aria-label="Session notes workspace">
          <p class="helper-text">
            Capture prep, live beats, and reflections without crowding the rest of the toolkit.
          </p>
          <form id="session-form">
            <div class="session-workspace">
              <aside class="session-timeline" aria-label="Session timeline">
                <div class="session-timeline__header">
                  <h3>Session Timeline</h3>
                  <p class="helper-text">
                    Pick a session and jump into prep, run, or review notes from the timeline.
                  </p>
                </div>
                <div class="session-timeline__list" id="session-timeline-list"></div>
              </aside>

              <div class="session-notes-pane" aria-live="polite">
                <div class="session-notes-header">
                  <div>
                    <h3 id="session-active-title">Session Notes</h3>
                    <p class="helper-text" id="session-active-meta">
                      Select a session card to update prep, run, or review notes.
                    </p>
                  </div>
                  <div class="session-actions">
                    <button id="session-save" type="submit">Save Notes</button>
                    <button id="session-reset" class="secondary" type="button">Clear Notes</button>
                    <span class="session-status" id="session-status-note">Not saved yet.</span>
                  </div>
                </div>

                <div class="session-card">
                  <h3>Session Overview</h3>
                  <div class="session-grid">
                    <div>
                      <label for="session-title">Session title</label>
                      <input
                        id="session-title"
                        name="session-title"
                        type="text"
                        placeholder="e.g. Echoes of the Emerald Vault"
                      />
                    </div>
                    <div>
                      <label for="session-number">Session #</label>
                      <input
                        id="session-number"
                        name="session-number"
                        type="number"
                        min="1"
                        placeholder="e.g. 12"
                      />
                    </div>
                    <div>
                      <label for="session-date">Date</label>
                      <input id="session-date" name="session-date" type="date" />
                    </div>
                    <div>
                      <label for="session-location">Party location</label>
                      <input
                        id="session-location"
                        name="session-location"
                        type="text"
                        placeholder="e.g. Bright Harbor"
                      />
                    </div>
                    <div>
                      <label for="session-status">Session status</label>
                      <select id="session-status" name="session-status">
                        <option value="prep">Prep</option>
                        <option value="live">In Play</option>
                        <option value="review">Review</option>
                      </select>
                    </div>
                    <div>
                      <label for="session-tags">Quick tags</label>
                      <input
                        id="session-tags"
                        name="session-tags"
                        type="text"
                        placeholder="e.g. heist, docks, vault"
                      />
                    </div>
                  </div>
                </div>

                <div class="session-view is-active" data-session-view="prep">
                  <div class="session-card">
                    <h3>Prep Essentials</h3>
                    <div class="session-grid">
                      <div>
                        <label for="session-goal">Session goal</label>
                        <input
                          id="session-goal"
                          name="session-goal"
                          type="text"
                          placeholder="e.g. Resolve the heist and confront the patron."
                        />
                      </div>
                      <div>
                        <label for="session-prep-priorities">Prep priorities</label>
                        <textarea
                          id="session-prep-priorities"
                          name="session-prep-priorities"
                          class="session-textarea--short"
                          placeholder="Key beats, rules to review, props to gather."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-prep-scenes">Planned scenes</label>
                        <textarea
                          id="session-prep-scenes"
                          name="session-prep-scenes"
                          class="session-textarea--short"
                          placeholder="Scene outline, transitions, or set pieces."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-prep-npcs">NPCs & assets</label>
                        <textarea
                          id="session-prep-npcs"
                          name="session-prep-npcs"
                          class="session-textarea--short"
                          placeholder="NPC beats, handouts, and reference notes."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-prep-locations">Locations & set dressing</label>
                        <textarea
                          id="session-prep-locations"
                          name="session-prep-locations"
                          class="session-textarea--short"
                          placeholder="Map callouts, ambiance cues, or travel beats."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-prep-encounters">Encounters & challenges</label>
                        <textarea
                          id="session-prep-encounters"
                          name="session-prep-encounters"
                          class="session-textarea--short"
                          placeholder="Combat setups, skill challenges, or hazards."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-prep-handouts">Props & handouts</label>
                        <textarea
                          id="session-prep-handouts"
                          name="session-prep-handouts"
                          class="session-textarea--short"
                          placeholder="Maps, letters, puzzles, or music cues."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-prep-risks">Risks & stakes</label>
                        <textarea
                          id="session-prep-risks"
                          name="session-prep-risks"
                          class="session-textarea--short"
                          placeholder="Failure states, consequences, or timers."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-prep-contingencies">Contingency plan</label>
                        <textarea
                          id="session-prep-contingencies"
                          name="session-prep-contingencies"
                          class="session-textarea--short"
                          placeholder="Plan B beats, fallback NPCs, or pacing levers."
                        ></textarea>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="session-view" data-session-view="run">
                  <div class="session-card">
                    <h3>Prep Snapshot for Live Play</h3>
                    <div class="session-summary-grid">
                      <div class="session-summary-item">
                        <strong>Goal</strong>
                        <span id="session-summary-goal">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Priorities</strong>
                        <span id="session-summary-priorities">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Scenes</strong>
                        <span id="session-summary-scenes">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>NPCs & Assets</strong>
                        <span id="session-summary-npcs">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Locations</strong>
                        <span id="session-summary-locations">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Encounters</strong>
                        <span id="session-summary-encounters">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Handouts</strong>
                        <span id="session-summary-handouts">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Risks & Stakes</strong>
                        <span id="session-summary-risks">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Contingencies</strong>
                        <span id="session-summary-contingencies">—</span>
                      </div>
                    </div>
                  </div>

                  <div class="session-card">
                    <h3>Run Sheet</h3>
                    <div class="session-grid">
                      <div>
                        <label for="session-run-recap">Opening recap</label>
                        <textarea
                          id="session-run-recap"
                          name="session-run-recap"
                          class="session-textarea--short"
                          placeholder="Shareable recap or cold-open beats."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-run-log">Scene log</label>
                        <textarea
                          id="session-run-log"
                          name="session-run-log"
                          class="session-textarea--tall"
                          placeholder="Key events, scene outcomes, and pacing notes."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-run-rulings">Rulings & changes</label>
                        <textarea
                          id="session-run-rulings"
                          name="session-run-rulings"
                          class="session-textarea--short"
                          placeholder="House rulings, adjustments, or rules reminders."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-run-loot">Loot & rewards</label>
                        <textarea
                          id="session-run-loot"
                          name="session-run-loot"
                          class="session-textarea--short"
                          placeholder="Treasure, boons, and quest rewards."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-run-moments">Player moments</label>
                        <textarea
                          id="session-run-moments"
                          name="session-run-moments"
                          class="session-textarea--short"
                          placeholder="Spotlight moments, heroic beats, or quotes."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-run-pacing">Pacing & energy</label>
                        <textarea
                          id="session-run-pacing"
                          name="session-run-pacing"
                          class="session-textarea--short"
                          placeholder="Where the table sped up, slowed down, or needed a break."
                        ></textarea>
                      </div>
                    </div>
                  </div>

                  <div class="session-card">
                    <h3>Live Table Prompts</h3>
                    <div class="session-grid">
                      <div>
                        <label for="session-run-pinned">Pinned reminders</label>
                        <textarea
                          id="session-run-pinned"
                          name="session-run-pinned"
                          class="session-textarea--short"
                          placeholder="Reminder cues to keep on screen."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-run-spotlights">Player spotlights</label>
                        <textarea
                          id="session-run-spotlights"
                          name="session-run-spotlights"
                          class="session-textarea--short"
                          placeholder="Who needs a spotlight beat or callback?"
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-run-questions">Open questions</label>
                        <textarea
                          id="session-run-questions"
                          name="session-run-questions"
                          class="session-textarea--short"
                          placeholder="Mysteries, decisions, or clues to answer soon."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-run-conditions">Table conditions</label>
                        <textarea
                          id="session-run-conditions"
                          name="session-run-conditions"
                          class="session-textarea--short"
                          placeholder="Safety tool reminders, breaks, or accessibility needs."
                        ></textarea>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="session-view" data-session-view="review">
                  <div class="session-card">
                    <h3>Prep + Run Highlights</h3>
                    <div class="session-summary-grid">
                      <div class="session-summary-item">
                        <strong>Goal</strong>
                        <span id="session-summary-review-goal">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Scenes</strong>
                        <span id="session-summary-review-scenes">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>NPCs & Assets</strong>
                        <span id="session-summary-review-npcs">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Scene Log</strong>
                        <span id="session-summary-review-log">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Rulings</strong>
                        <span id="session-summary-review-rulings">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Loot & Rewards</strong>
                        <span id="session-summary-review-loot">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Player Moments</strong>
                        <span id="session-summary-review-moments">—</span>
                      </div>
                      <div class="session-summary-item">
                        <strong>Pacing & Energy</strong>
                        <span id="session-summary-review-pacing">—</span>
                      </div>
                    </div>
                  </div>

                  <div class="session-card">
                    <h3>Review & Follow-Ups</h3>
                    <div class="session-grid">
                      <div>
                        <label for="session-review-outcomes">Outcomes</label>
                        <textarea
                          id="session-review-outcomes"
                          name="session-review-outcomes"
                          class="session-textarea--short"
                          placeholder="What changed? What did the party accomplish?"
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-review-loose-ends">Loose ends</label>
                        <textarea
                          id="session-review-loose-ends"
                          name="session-review-loose-ends"
                          class="session-textarea--short"
                          placeholder="Unresolved threads or NPC follow-ups."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-review-next">Next session plan</label>
                        <textarea
                          id="session-review-next"
                          name="session-review-next"
                          class="session-textarea--short"
                          placeholder="Prep to carry forward into the next session."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-review-feedback">Player feedback</label>
                        <textarea
                          id="session-review-feedback"
                          name="session-review-feedback"
                          class="session-textarea--short"
                          placeholder="Table feedback, tone notes, or spotlight wins."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-review-rewards">Advancement & rewards</label>
                        <textarea
                          id="session-review-rewards"
                          name="session-review-rewards"
                          class="session-textarea--short"
                          placeholder="XP, milestone notes, downtime actions, or boons."
                        ></textarea>
                      </div>
                      <div>
                        <label for="session-review-improvements">GM improvements</label>
                        <textarea
                          id="session-review-improvements"
                          name="session-review-improvements"
                          class="session-textarea--short"
                          placeholder="What to adjust next time for smoother play."
                        ></textarea>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="session-card">
                  <h3>Session Pulse</h3>
                  <p class="helper-text">
                    Auto-save runs while you type to keep live notes safe.
                  </p>
                  <p class="session-status" id="session-last-saved">Last saved: —</p>
                </div>
              </div>
            </div>
          </form>
        </section>
      </div>
    </section>

    <!-- Initiative input lightbox -->
    <div id="initiative-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal">
        <h3>Enter Initiative Rolls</h3>
        <p class="helper-text">
          Confirm each participant's initiative before starting the encounter.
        </p>
        <div id="initiative-list" class="modal-list"></div>
        <div class="modal-actions">
          <button id="initiative-cancel" class="ghost" type="button">Cancel</button>
          <button id="initiative-confirm" type="button">Begin Encounter</button>
        </div>
      </div>
    </div>

    <!-- Marker editor lightbox -->
    <div id="marker-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal">
        <h3>Add Marker</h3>
        <p class="helper-text">
          Add a condition or reminder with an optional duration. Duration is counted from the
          selected participant's turn.
        </p>
        <form id="marker-form">
          <div class="modal-list">
            <div>
              <label for="marker-target">Add marker to</label>
              <select id="marker-target" required></select>
            </div>
            <div>
              <label for="marker-condition">Preset condition (optional)</label>
              <select id="marker-condition"></select>
            </div>
            <div>
              <label for="marker-label">Custom label</label>
              <input
                id="marker-label"
                type="text"
                placeholder="e.g. Bless +1 morale"
              />
            </div>
            <div>
              <label for="marker-duration">Duration (rounds, optional)</label>
              <input
                id="marker-duration"
                type="number"
                min="1"
                placeholder="e.g. 3"
              />
            </div>
            <div>
              <label for="marker-start">Start counting on</label>
              <select id="marker-start" required></select>
            </div>
          </div>
          <div class="modal-actions">
            <button id="marker-cancel" class="ghost" type="button">Cancel</button>
            <button type="submit">Save Marker</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Marker expiry prompt lightbox -->
    <div id="expiry-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal">
        <h3>Marker Expiring</h3>
        <p id="expiry-message" class="helper-text"></p>
        <div class="modal-actions">
          <button id="expiry-keep" class="ghost" type="button">Keep</button>
          <button id="expiry-remove" type="button">Remove</button>
        </div>
      </div>
    </div>

    <!-- Footer for thematic close -->
    <footer>
      <div class="container">
        <p>Keep your notes close and your dice closer.</p>
      </div>
    </footer>

    <script>
      // ------------------------------
      // Toolkit Module Logic
      // ------------------------------
      // Local storage schema keeps module data expandable for future tools.
      const STORAGE_KEY = "pfToolkitMemory";
      const STORAGE_VERSION = 4;
      const conditionPresets = [
        "Blinded",
        "Confused",
        "Cowering",
        "Dazzled",
        "Dazed",
        "Deafened",
        "Entangled",
        "Exhausted",
        "Fatigued",
        "Fascinated",
        "Frightened",
        "Grappled",
        "Helpless",
        "Nauseated",
        "Panicked",
        "Paralyzed",
        "Petrified",
        "Pinned",
        "Prone",
        "Shaken",
        "Sickened",
        "Staggered",
        "Stunned",
        "Unconscious",
      ];

      // Challenge rating reference list powers monster XP and encounter summaries.
      const challengeRatings = [
        { value: "1/8", label: "1/8", xp: 50 },
        { value: "1/6", label: "1/6", xp: 65 },
        { value: "1/4", label: "1/4", xp: 100 },
        { value: "1/3", label: "1/3", xp: 135 },
        { value: "1/2", label: "1/2", xp: 200 },
        { value: "1", label: "1", xp: 400 },
        { value: "2", label: "2", xp: 600 },
        { value: "3", label: "3", xp: 800 },
        { value: "4", label: "4", xp: 1200 },
        { value: "5", label: "5", xp: 1600 },
        { value: "6", label: "6", xp: 2400 },
        { value: "7", label: "7", xp: 3200 },
        { value: "8", label: "8", xp: 4800 },
        { value: "9", label: "9", xp: 6400 },
        { value: "10", label: "10", xp: 9600 },
        { value: "11", label: "11", xp: 12800 },
        { value: "12", label: "12", xp: 19200 },
        { value: "13", label: "13", xp: 25600 },
        { value: "14", label: "14", xp: 38400 },
        { value: "15", label: "15", xp: 51200 },
        { value: "16", label: "16", xp: 76800 },
        { value: "17", label: "17", xp: 102400 },
        { value: "18", label: "18", xp: 153600 },
        { value: "19", label: "19", xp: 204800 },
        { value: "20", label: "20", xp: 307200 },
      ];

      // Session note defaults keep the timeline ready for prep/run/review workflows.
      const defaultSessionEntryData = () => ({
        title: "",
        number: "",
        date: "",
        location: "",
        status: "prep",
        tags: "",
        goal: "",
        prep: {
          priorities: "",
          scenes: "",
          npcs: "",
          locations: "",
          encounters: "",
          handouts: "",
          risks: "",
          contingencies: "",
        },
        run: {
          recap: "",
          log: "",
          rulings: "",
          loot: "",
          moments: "",
          pacing: "",
          pinned: "",
          spotlights: "",
          questions: "",
          conditions: "",
        },
        review: {
          outcomes: "",
          looseEnds: "",
          next: "",
          feedback: "",
          rewards: "",
          improvements: "",
        },
        lastSaved: null,
      });

      const state = {
        participants: [],
        encounterStarted: false,
        rewardsGranted: false,
        round: 1,
        turnIndex: 0,
        promptQueue: [],
        pendingAdvance: false,
        editingTargetId: null,
        activeEncounterId: null,
      };

      // NPC vault state is isolated to keep roster workflows decoupled from combat state.
      const npcState = {
        roster: [],
        activeNpcId: null,
        editingNpcId: null,
      };

      // Creature library state keeps roster data and export selections together.
      const creatureState = {
        roster: [],
        activeCreatureId: null,
        editingCreatureId: null,
        selectedCreatureIds: new Set(),
      };

      // NPC wizard state keeps step navigation aligned with modal progress.
      const npcWizardState = {
        step: 1,
        total: 6,
      };

      // Session notes state tracks the timeline, active view, and auto-save timing.
      const sessionState = {
        sessions: [],
        activeSessionId: null,
        activeView: "prep",
        autoSaveTimer: null,
      };

      // Cache DOM nodes once for performance and clarity.
      const participantForm = document.getElementById("participant-form");
      const participantName = document.getElementById("participant-name");
      const participantType = document.getElementById("participant-type");
      const participantCrField = document.getElementById("participant-cr-field");
      const participantCr = document.getElementById("participant-cr");
      const startEncounterButton = document.getElementById("start-encounter");
      const roundCount = document.getElementById("round-count");
      const currentParticipantLabel = document.getElementById("current-participant");
      const nextTurnButton = document.getElementById("next-turn");
      const previousTurnButton = document.getElementById("previous-turn");
      const participantBody = document.getElementById("participant-body");
      const rewardEncounterButton = document.getElementById("reward-encounter");
      const rewardStatus = document.getElementById("reward-status");
      const encounterCrValue = document.getElementById("encounter-cr");
      const totalXpValue = document.getElementById("total-xp");
      const xpPerPlayerValue = document.getElementById("xp-per-player");
      const encounterStatus = document.getElementById("encounter-status");

      const initiativeModal = document.getElementById("initiative-modal");
      const initiativeList = document.getElementById("initiative-list");
      const initiativeCancel = document.getElementById("initiative-cancel");
      const initiativeConfirm = document.getElementById("initiative-confirm");

      const encounterList = document.getElementById("encounter-list");
      const encounterNameInput = document.getElementById("encounter-name");
      const createEncounterButton = document.getElementById("create-encounter");
      const saveEncounterButton = document.getElementById("save-encounter");
      const encounterStatusNote = document.getElementById("encounter-status-note");

      const markerModal = document.getElementById("marker-modal");
      const markerForm = document.getElementById("marker-form");
      const markerTarget = document.getElementById("marker-target");
      const markerCondition = document.getElementById("marker-condition");
      const markerLabel = document.getElementById("marker-label");
      const markerDuration = document.getElementById("marker-duration");
      const markerStart = document.getElementById("marker-start");
      const markerCancel = document.getElementById("marker-cancel");

      const expiryModal = document.getElementById("expiry-modal");
      const expiryMessage = document.getElementById("expiry-message");
      const expiryKeep = document.getElementById("expiry-keep");
      const expiryRemove = document.getElementById("expiry-remove");

      // Header elements keep the app title concise while highlighting the active module.
      const headerModule = document.getElementById("active-module");
      const headerDescription = document.getElementById("module-description");

      // Module navigation elements keep the dashboard and tracker in separate views.
      const dashboardView = document.getElementById("dashboard-view");
      const initiativeModule = document.getElementById("initiative-module");
      const initiativeLaunch = document.getElementById("initiative-launch");
      const startSessionAction = document.getElementById("start-session-action");
      const initiativeBack = document.getElementById("initiative-back");
      const encounterPanelToggle = document.getElementById("encounter-panel-toggle");
      const encounterPanelToggleCollapsed = document.getElementById("encounter-panel-toggle-collapsed");
      const encounterPanelCollapsedHandle = document.getElementById("encounter-panel-collapsed-handle");
      const trackerLayout = document.getElementById("tracker-layout");
      const encounterPanelContent = document.getElementById("encounter-panel-content");

      // NPC vault elements control module navigation, form inputs, and list rendering.
      const npcModule = document.getElementById("npc-module");
      const npcLaunch = document.getElementById("npc-launch");
      const npcBack = document.getElementById("npc-back");
      const npcCreate = document.getElementById("npc-create");
      const npcCreateInline = document.getElementById("npc-create-inline");
      const npcModal = document.getElementById("npc-modal");
      const npcModalClose = document.getElementById("npc-modal-close");
      const npcModalTitle = document.getElementById("npc-modal-title");
      const npcModalStep = document.getElementById("npc-modal-step");
      const npcProgress = document.querySelector(".npc-progress");
      const npcProgressBar = document.getElementById("npc-progress-bar");
      const npcStepBack = document.getElementById("npc-step-back");
      const npcStepNext = document.getElementById("npc-step-next");
      const npcForm = document.getElementById("npc-form");
      const npcName = document.getElementById("npc-name");
      const npcRole = document.getElementById("npc-role");
      const npcFaction = document.getElementById("npc-faction");
      const npcLocation = document.getElementById("npc-location");
      const npcAncestry = document.getElementById("npc-ancestry");
      const npcClass = document.getElementById("npc-class");
      const npcLevel = document.getElementById("npc-level");
      const npcAlignment = document.getElementById("npc-alignment");
      const npcSize = document.getElementById("npc-size");
      const npcDisposition = document.getElementById("npc-disposition");
      const npcRelationship = document.getElementById("npc-relationship");
      const npcTags = document.getElementById("npc-tags");
      const npcHp = document.getElementById("npc-hp");
      const npcAc = document.getElementById("npc-ac");
      const npcSpeed = document.getElementById("npc-speed");
      const npcInitiative = document.getElementById("npc-initiative");
      const npcStrength = document.getElementById("npc-str");
      const npcDexterity = document.getElementById("npc-dex");
      const npcConstitution = document.getElementById("npc-con");
      const npcIntelligence = document.getElementById("npc-int");
      const npcWisdom = document.getElementById("npc-wis");
      const npcCharisma = document.getElementById("npc-cha");
      const npcFortitude = document.getElementById("npc-fortitude");
      const npcReflex = document.getElementById("npc-reflex");
      const npcWill = document.getElementById("npc-will");
      const npcSenses = document.getElementById("npc-senses");
      const npcLanguages = document.getElementById("npc-languages");
      const npcHook = document.getElementById("npc-hook");
      const npcSkills = document.getElementById("npc-skills");
      const npcEquipment = document.getElementById("npc-equipment");
      const npcAbilities = document.getElementById("npc-abilities");
      const npcNotes = document.getElementById("npc-notes");
      const npcSubmit = document.getElementById("npc-submit");
      const npcReset = document.getElementById("npc-reset");
      const npcFormNote = document.getElementById("npc-form-note");
      const npcList = document.getElementById("npc-list");
      const npcEmptyState = document.getElementById("npc-empty-state");
      const npcDetail = document.getElementById("npc-detail");
      const npcSteps = Array.from(document.querySelectorAll(".npc-step"));

      // Creature library elements manage stat card entry, selection, and export flows.
      const creatureModule = document.getElementById("creature-module");
      const creatureLaunch = document.getElementById("creature-launch");
      const creatureBack = document.getElementById("creature-back");
      const creatureNew = document.getElementById("creature-new");
      const creatureExport = document.getElementById("creature-export");
      const creatureExportSelected = document.getElementById("creature-export-selected");
      const creatureSelectAll = document.getElementById("creature-select-all");
      const creatureClearSelection = document.getElementById("creature-clear-selection");
      const creatureList = document.getElementById("creature-list");
      const creatureEmptyState = document.getElementById("creature-empty-state");
      const creatureSelectionCount = document.getElementById("creature-selection-count");
      const creatureFormTitle = document.getElementById("creature-form-title");
      const creatureForm = document.getElementById("creature-form");
      const creatureFormNote = document.getElementById("creature-form-note");
      const creatureStatblock = document.getElementById("creature-statblock");
      const creatureParse = document.getElementById("creature-parse");
      const creatureClearStatblock = document.getElementById("creature-clear-statblock");
      const creatureName = document.getElementById("creature-name");
      const creatureLevel = document.getElementById("creature-level");
      const creatureRole = document.getElementById("creature-role");
      const creatureTraits = document.getElementById("creature-traits");
      const creatureAlignment = document.getElementById("creature-alignment");
      const creatureSize = document.getElementById("creature-size");
      const creaturePerception = document.getElementById("creature-perception");
      const creatureSenses = document.getElementById("creature-senses");
      const creatureLanguages = document.getElementById("creature-languages");
      const creatureAc = document.getElementById("creature-ac");
      const creatureHp = document.getElementById("creature-hp");
      const creatureFortitude = document.getElementById("creature-fortitude");
      const creatureReflex = document.getElementById("creature-reflex");
      const creatureWill = document.getElementById("creature-will");
      const creatureResistances = document.getElementById("creature-resistances");
      const creatureWeaknesses = document.getElementById("creature-weaknesses");
      const creatureImmunities = document.getElementById("creature-immunities");
      const creatureSpeed = document.getElementById("creature-speed");
      const creatureMelee = document.getElementById("creature-melee");
      const creatureRanged = document.getElementById("creature-ranged");
      const creatureAbilities = document.getElementById("creature-abilities");
      const creatureSkills = document.getElementById("creature-skills");
      const creatureNotes = document.getElementById("creature-notes");
      const creatureSave = document.getElementById("creature-save");
      const creatureReset = document.getElementById("creature-reset");

      // Session notes elements wire the MVP note capture form.
      const sessionModule = document.getElementById("session-module");
      const sessionLaunch = document.getElementById("session-launch");
      const continuePrepAction = document.getElementById("continue-prep-action");
      const sessionBack = document.getElementById("session-back");
      const sessionForm = document.getElementById("session-form");
      const sessionSave = document.getElementById("session-save");
      const sessionReset = document.getElementById("session-reset");
      const sessionStatusNote = document.getElementById("session-status-note");
      const sessionLastSaved = document.getElementById("session-last-saved");
      const sessionTimelineList = document.getElementById("session-timeline-list");
      const sessionActiveTitle = document.getElementById("session-active-title");
      const sessionActiveMeta = document.getElementById("session-active-meta");
      const sessionViewSections = Array.from(document.querySelectorAll("[data-session-view]"));
      const sessionTitle = document.getElementById("session-title");
      const sessionNumber = document.getElementById("session-number");
      const sessionDate = document.getElementById("session-date");
      const sessionLocation = document.getElementById("session-location");
      const sessionStatus = document.getElementById("session-status");
      const sessionGoal = document.getElementById("session-goal");
      const sessionTags = document.getElementById("session-tags");
      const sessionPrepPriorities = document.getElementById("session-prep-priorities");
      const sessionPrepScenes = document.getElementById("session-prep-scenes");
      const sessionPrepNpcs = document.getElementById("session-prep-npcs");
      const sessionPrepLocations = document.getElementById("session-prep-locations");
      const sessionPrepEncounters = document.getElementById("session-prep-encounters");
      const sessionPrepHandouts = document.getElementById("session-prep-handouts");
      const sessionPrepRisks = document.getElementById("session-prep-risks");
      const sessionPrepContingencies = document.getElementById("session-prep-contingencies");
      const sessionRunRecap = document.getElementById("session-run-recap");
      const sessionRunLog = document.getElementById("session-run-log");
      const sessionRunRulings = document.getElementById("session-run-rulings");
      const sessionRunLoot = document.getElementById("session-run-loot");
      const sessionRunMoments = document.getElementById("session-run-moments");
      const sessionRunPacing = document.getElementById("session-run-pacing");
      const sessionRunPinned = document.getElementById("session-run-pinned");
      const sessionRunSpotlights = document.getElementById("session-run-spotlights");
      const sessionRunQuestions = document.getElementById("session-run-questions");
      const sessionRunConditions = document.getElementById("session-run-conditions");
      const sessionReviewOutcomes = document.getElementById("session-review-outcomes");
      const sessionReviewLooseEnds = document.getElementById("session-review-loose-ends");
      const sessionReviewNext = document.getElementById("session-review-next");
      const sessionReviewFeedback = document.getElementById("session-review-feedback");
      const sessionReviewRewards = document.getElementById("session-review-rewards");
      const sessionReviewImprovements = document.getElementById("session-review-improvements");
      const sessionSummaryGoal = document.getElementById("session-summary-goal");
      const sessionSummaryPriorities = document.getElementById("session-summary-priorities");
      const sessionSummaryScenes = document.getElementById("session-summary-scenes");
      const sessionSummaryNpcs = document.getElementById("session-summary-npcs");
      const sessionSummaryLocations = document.getElementById("session-summary-locations");
      const sessionSummaryEncounters = document.getElementById("session-summary-encounters");
      const sessionSummaryHandouts = document.getElementById("session-summary-handouts");
      const sessionSummaryRisks = document.getElementById("session-summary-risks");
      const sessionSummaryContingencies = document.getElementById("session-summary-contingencies");
      const sessionSummaryReviewGoal = document.getElementById("session-summary-review-goal");
      const sessionSummaryReviewScenes = document.getElementById("session-summary-review-scenes");
      const sessionSummaryReviewNpcs = document.getElementById("session-summary-review-npcs");
      const sessionSummaryReviewLog = document.getElementById("session-summary-review-log");
      const sessionSummaryReviewRulings = document.getElementById("session-summary-review-rulings");
      const sessionSummaryReviewLoot = document.getElementById("session-summary-review-loot");
      const sessionSummaryReviewMoments = document.getElementById("session-summary-review-moments");
      const sessionSummaryReviewPacing = document.getElementById("session-summary-review-pacing");

      // Single source of truth for header copy across dashboard and module views.
      const headerCopy = {
        dashboard: {
          module: "Current Campaign Plan",
          description:
            "Review upcoming sessions, prep priorities, and launch tools as secondary panels from this workspace.",
        },
        initiative: {
          module: "Initiative Tracker",
          description: "Run turn order, condition tracking, and round pacing, then return to the campaign plan.",
        },
        npc: {
          module: "NPC Vault",
          description: "Capture NPC profiles and return linked notes to the campaign planning workspace.",
        },
        creature: {
          module: "Creature Library",
          description: "Manage linked creature cards used by your current campaign plan.",
        },
        session: {
          module: "Session Notes",
          description: "Continue prep and live notes tied directly to your current campaign plan.",
        },
      };

      const updateHeader = (viewKey) => {
        const copy = headerCopy[viewKey];
        if (!copy) {
          return;
        }
        headerModule.textContent = copy.module;
        headerDescription.textContent = copy.description;
      };

      // Control visibility and accessibility state for the encounter drawer toggle.
      const setEncounterPanelVisibility = (isVisible) => {
        trackerLayout.classList.toggle("is-collapsed", !isVisible);
        encounterPanelToggle.setAttribute("aria-expanded", String(isVisible));
        encounterPanelContent.setAttribute("aria-hidden", String(!isVisible));
        encounterPanelToggle.setAttribute(
          "aria-label",
          isVisible ? "Collapse Encounter Library" : "Expand Encounter Library"
        );
        encounterPanelToggle.title = isVisible ? "Collapse Encounter Library" : "Expand Encounter Library";
        encounterPanelToggle.tabIndex = isVisible ? 0 : -1;
        encounterPanelToggleCollapsed.setAttribute("aria-expanded", String(isVisible));
        encounterPanelToggleCollapsed.setAttribute(
          "aria-label",
          isVisible ? "Collapse Encounter Library" : "Expand Encounter Library"
        );
        encounterPanelToggleCollapsed.title = isVisible
          ? "Collapse Encounter Library"
          : "Expand Encounter Library";
        encounterPanelToggleCollapsed.tabIndex = isVisible ? -1 : 0;
        encounterPanelCollapsedHandle.setAttribute("aria-hidden", String(isVisible));
      };

      // Utility helpers keep state changes predictable and documented.
      const generateId = () => `id-${Math.random().toString(16).slice(2, 10)}`;

      // Build a session entry with a stable identifier and optional overrides.
      const createSessionEntry = (overrides = {}) => ({
        id: overrides.id ?? generateId(),
        ...defaultSessionEntryData(),
        ...overrides,
        prep: {
          ...defaultSessionEntryData().prep,
          ...(overrides.prep ?? {}),
        },
        run: {
          ...defaultSessionEntryData().run,
          ...(overrides.run ?? {}),
        },
        review: {
          ...defaultSessionEntryData().review,
          ...(overrides.review ?? {}),
        },
      });

      // Seed a timeline with a few starter sessions to illustrate workflow sections.
      const createSeedSessions = () => [
        createSessionEntry({
          title: "Echoes of the Emerald Vault",
          number: "12",
          date: "",
          location: "Bright Harbor",
          status: "prep",
          tags: "vault, docks, heist",
          goal: "Resolve the heist and confront the patron.",
          prep: {
            priorities: "Finalize the vault warding rules and prep the getaway chase.",
            scenes: "Dockside intel, vault infiltration, patron reveal.",
            npcs: "Patron Virel, Dockmaster Kessa, Vault Captain Orr.",
            locations: "Bright Harbor docks, Emerald Vault, back-alley escape route.",
            encounters: "Clockwork sentries, rooftop chase skill challenge.",
            handouts: "Vault schematic, patron letter, chase tracker.",
            risks: "Alarm triggers pursuit; patron double-crosses mid-escape.",
            contingencies: "If the heist stalls, trigger rival crew interference.",
          },
        }),
        createSessionEntry({
          title: "Shadows Over Sapphire Keep",
          number: "13",
          date: "",
          location: "Sapphire Keep",
          status: "live",
          tags: "siege, keep, intrigue",
          goal: "Survive the midnight siege and secure the relic vault.",
        }),
        createSessionEntry({
          title: "Hollowspire Aftermath",
          number: "14",
          date: "",
          location: "Hollowspire",
          status: "review",
          tags: "aftermath, mysteries",
          goal: "Debrief the tower collapse and decide next leads.",
        }),
      ];

      // Migrate legacy single-note storage into the new multi-session timeline format.
      const buildSessionFromLegacy = (legacyNote = {}) =>
        createSessionEntry({
          title: legacyNote.title ?? "",
          number: legacyNote.number ?? "",
          date: legacyNote.date ?? "",
          location: legacyNote.location ?? "",
          status: legacyNote.status ?? "prep",
          tags: legacyNote.tags ?? "",
          goal: legacyNote.goal ?? "",
          prep: {
            priorities: legacyNote.prepPriorities ?? "",
            scenes: legacyNote.prepScenes ?? "",
            npcs: legacyNote.prepNpcs ?? "",
          },
          run: {
            log: legacyNote.liveLog ?? "",
            rulings: legacyNote.liveRulings ?? "",
            loot: legacyNote.liveLoot ?? "",
            moments: legacyNote.liveMoments ?? "",
            pinned: legacyNote.pinned ?? "",
            spotlights: legacyNote.spotlights ?? "",
            questions: legacyNote.questions ?? "",
          },
          review: {
            outcomes: legacyNote.reflectionOutcomes ?? "",
            looseEnds: legacyNote.reflectionLooseEnds ?? "",
            next: legacyNote.reflectionNext ?? "",
          },
          lastSaved: legacyNote.lastSaved ?? null,
        });

      const formatXp = (xp) => xp.toLocaleString();

      const getChallengeRatingData = (challengeRating) =>
        challengeRatings.find((rating) => rating.value === challengeRating) ?? null;

      const getXpForChallengeRating = (challengeRating) => getChallengeRatingData(challengeRating)?.xp ?? 0;

      const isMonsterType = (type) => type.toLowerCase() === "monster";

      const isPlayerEquivalent = (type) => {
        const normalized = type.toLowerCase();
        return normalized === "player" || normalized === "npc";
      };

      // Encounter summary logic translates monster CRs into XP totals and a derived CR.
      // NPCs are treated as player equivalents for XP splitting per encounter rules.
      const getEncounterSummary = () => {
        const totalXp = state.participants.reduce((sum, participant) => {
          if (!isMonsterType(participant.type)) {
            return sum;
          }
          return sum + getXpForChallengeRating(participant.challengeRating);
        }, 0);
        const playerCount = state.participants.filter((participant) =>
          isPlayerEquivalent(participant.type)
        ).length;
        const xpPerPlayer = playerCount ? Math.floor(totalXp / playerCount) : 0;
        const closestCr = challengeRatings.reduce((closest, rating) => {
          if (!closest) {
            return rating;
          }
          return Math.abs(rating.xp - totalXp) < Math.abs(closest.xp - totalXp) ? rating : closest;
        }, null);
        return {
          totalXp,
          xpPerPlayer,
          encounterCr: totalXp ? closestCr?.label ?? "—" : "—",
          playerCount,
        };
      };

      const loadMemory = () => {
        const raw = window.localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          const seededSessions = createSeedSessions();
          return {
            version: STORAGE_VERSION,
            modules: {
              initiative: { encounters: [], activeEncounterId: null },
              npc: { roster: [], activeNpcId: null },
              session: {
                sessions: seededSessions,
                activeSessionId: seededSessions[0]?.id ?? null,
              },
            },
          };
        }
        try {
          const parsed = JSON.parse(raw);
          const parsedSession = parsed.modules?.session ?? {};
          const legacyNote = parsedSession.note ?? null;
          const sessionsFromLegacy = legacyNote ? [buildSessionFromLegacy(legacyNote)] : null;
          const sessions = parsedSession.sessions ?? sessionsFromLegacy ?? createSeedSessions();
          const activeSessionId =
            parsedSession.activeSessionId ?? sessions[0]?.id ?? null;
          return {
            version: parsed.version ?? STORAGE_VERSION,
            modules: {
              initiative: {
                encounters: parsed.modules?.initiative?.encounters ?? [],
                activeEncounterId: parsed.modules?.initiative?.activeEncounterId ?? null,
              },
              npc: {
                roster: parsed.modules?.npc?.roster ?? [],
                activeNpcId: parsed.modules?.npc?.activeNpcId ?? null,
              },
              session: {
                sessions,
                activeSessionId,
              },
            },
          };
        } catch (error) {
          console.warn("Failed to parse local storage memory, resetting.", error);
          const seededSessions = createSeedSessions();
          return {
            version: STORAGE_VERSION,
            modules: {
              initiative: { encounters: [], activeEncounterId: null },
              npc: { roster: [], activeNpcId: null },
              session: {
                sessions: seededSessions,
                activeSessionId: seededSessions[0]?.id ?? null,
              },
            },
          };
        }
      };

      const saveMemory = (memory) => {
        window.localStorage.setItem(STORAGE_KEY, JSON.stringify(memory));
      };

      const getInitiativeMemory = () => loadMemory().modules.initiative;

      const getNpcMemory = () => loadMemory().modules.npc;

      const getSessionMemory = () => loadMemory().modules.session;

      const updateInitiativeMemory = (updater) => {
        const memory = loadMemory();
        const updated = updater(memory.modules.initiative);
        memory.modules.initiative = updated;
        saveMemory(memory);
        return updated;
      };

      const updateNpcMemory = (updater) => {
        const memory = loadMemory();
        const updated = updater(memory.modules.npc);
        memory.modules.npc = updated;
        saveMemory(memory);
        return updated;
      };

      const updateSessionMemory = (updater) => {
        const memory = loadMemory();
        const updated = updater(memory.modules.session);
        memory.modules.session = updated;
        saveMemory(memory);
        return updated;
      };

      const hydrateStateFromEncounter = (encounter) => {
        state.participants = encounter.participants ?? [];
        state.encounterStarted = encounter.encounterStarted ?? false;
        state.rewardsGranted = encounter.rewardsGranted ?? false;
        state.round = encounter.round ?? 1;
        state.turnIndex = encounter.turnIndex ?? 0;
        state.activeEncounterId = encounter.id ?? null;
        state.promptQueue = [];
        state.pendingAdvance = false;
        state.editingTargetId = null;
      };

      // Keep the encounter name input aligned with the active encounter.
      const updateEncounterNameField = (name = "") => {
        encounterNameInput.value = name;
      };

      const buildEncounterPayload = (overrides = {}) => ({
        id: state.activeEncounterId ?? generateId(),
        name: overrides.name ?? "Untitled Encounter",
        participants: state.participants,
        encounterStarted: state.encounterStarted,
        rewardsGranted: state.rewardsGranted,
        round: state.round,
        turnIndex: state.turnIndex,
        updatedAt: new Date().toISOString(),
      });

      const persistActiveEncounter = () => {
        if (!state.activeEncounterId) {
          return;
        }
        updateInitiativeMemory((initiativeMemory) => {
          const encounters = initiativeMemory.encounters.map((encounter) =>
            encounter.id === state.activeEncounterId
              ? { ...encounter, ...buildEncounterPayload({ name: encounter.name }) }
              : encounter
          );
          return {
            ...initiativeMemory,
            encounters,
          };
        });
      };

      // ------------------------------
      // NPC Vault Helpers
      // ------------------------------
      // Normalize comma-separated tags into a clean array for display and filtering.
      const parseNpcTags = (value) =>
        value
          .split(",")
          .map((tag) => tag.trim())
          .filter(Boolean);

      // Parse numeric fields safely so empty or invalid entries store as null.
      const parseNpcNumberField = (value) => {
        const parsed = Number.parseInt(value, 10);
        return Number.isNaN(parsed) ? null : parsed;
      };

      // Provide a user-friendly label for display when data is missing.
      const formatNpcField = (value, fallback = "—") =>
        value === null || value === undefined || value === "" ? fallback : value;

      // Format the six core attributes into a compact display string.
      const formatNpcAttributes = (attributes) => {
        if (!attributes) {
          return "—";
        }
        const formatted = [
          `STR ${formatNpcField(attributes.strength)}`,
          `DEX ${formatNpcField(attributes.dexterity)}`,
          `CON ${formatNpcField(attributes.constitution)}`,
          `INT ${formatNpcField(attributes.intelligence)}`,
          `WIS ${formatNpcField(attributes.wisdom)}`,
          `CHA ${formatNpcField(attributes.charisma)}`,
        ];
        return formatted.join(" · ");
      };

      // Format saving throws into a concise, readable block.
      const formatNpcSaves = (saves) => {
        if (!saves) {
          return "—";
        }
        return [
          `Fort ${formatNpcField(saves.fortitude)}`,
          `Ref ${formatNpcField(saves.reflex)}`,
          `Will ${formatNpcField(saves.will)}`,
        ].join(" · ");
      };

      const getNpcById = (npcId) => npcState.roster.find((npc) => npc.id === npcId) ?? null;

      const setNpcFormNote = (message, isWarning = false) => {
        npcFormNote.textContent = message;
        npcFormNote.style.color = isWarning ? "var(--warning)" : "var(--ink-muted)";
      };

      const buildNpcPayload = (overrides = {}) => ({
        id: overrides.id ?? generateId(),
        name: overrides.name ?? npcName.value.trim(),
        role: overrides.role ?? npcRole.value.trim(),
        faction: overrides.faction ?? npcFaction.value.trim(),
        location: overrides.location ?? npcLocation.value.trim(),
        ancestry: overrides.ancestry ?? npcAncestry.value.trim(),
        className: overrides.className ?? npcClass.value.trim(),
        level: overrides.level ?? parseNpcNumberField(npcLevel.value),
        alignment: overrides.alignment ?? npcAlignment.value.trim(),
        size: overrides.size ?? npcSize.value,
        disposition: overrides.disposition ?? npcDisposition.value,
        relationship: overrides.relationship ?? npcRelationship.value,
        tags: overrides.tags ?? parseNpcTags(npcTags.value),
        hitPoints: overrides.hitPoints ?? parseNpcNumberField(npcHp.value),
        armorClass: overrides.armorClass ?? parseNpcNumberField(npcAc.value),
        speed: overrides.speed ?? npcSpeed.value.trim(),
        initiative: overrides.initiative ?? parseNpcNumberField(npcInitiative.value),
        attributes: overrides.attributes ?? {
          strength: parseNpcNumberField(npcStrength.value),
          dexterity: parseNpcNumberField(npcDexterity.value),
          constitution: parseNpcNumberField(npcConstitution.value),
          intelligence: parseNpcNumberField(npcIntelligence.value),
          wisdom: parseNpcNumberField(npcWisdom.value),
          charisma: parseNpcNumberField(npcCharisma.value),
        },
        saves: overrides.saves ?? {
          fortitude: parseNpcNumberField(npcFortitude.value),
          reflex: parseNpcNumberField(npcReflex.value),
          will: parseNpcNumberField(npcWill.value),
        },
        senses: overrides.senses ?? npcSenses.value.trim(),
        languages: overrides.languages ?? npcLanguages.value.trim(),
        hook: overrides.hook ?? npcHook.value.trim(),
        skills: overrides.skills ?? npcSkills.value.trim(),
        equipment: overrides.equipment ?? npcEquipment.value.trim(),
        abilities: overrides.abilities ?? npcAbilities.value.trim(),
        notes: overrides.notes ?? npcNotes.value.trim(),
        updatedAt: overrides.updatedAt ?? new Date().toISOString(),
      });

      // Update the NPC wizard UI to reflect the current step.
      const updateNpcWizardView = () => {
        const totalSteps = npcSteps.length || npcWizardState.total;
        npcWizardState.total = totalSteps;
        npcSteps.forEach((stepSection) => {
          const stepNumber = Number(stepSection.dataset.step);
          stepSection.classList.toggle("is-active", stepNumber === npcWizardState.step);
        });
        const activeStep = npcSteps.find(
          (stepSection) => Number(stepSection.dataset.step) === npcWizardState.step
        );
        const stepTitle = activeStep?.dataset.title ?? "NPC Details";
        npcModalStep.textContent = `Step ${npcWizardState.step} of ${totalSteps}: ${stepTitle}`;
        npcProgressBar.style.width = `${(npcWizardState.step / totalSteps) * 100}%`;
        npcProgress?.setAttribute("aria-valuenow", String(npcWizardState.step));
        npcStepBack.disabled = npcWizardState.step <= 1;
        npcStepNext.classList.toggle("is-hidden", npcWizardState.step >= totalSteps);
        npcSubmit.classList.toggle("is-hidden", npcWizardState.step < totalSteps);
      };

      // Move the wizard to a specific step, clamping within the step range.
      const setNpcWizardStep = (step) => {
        const totalSteps = npcSteps.length || npcWizardState.total;
        npcWizardState.step = Math.min(Math.max(step, 1), totalSteps);
        updateNpcWizardView();
      };

      // Open the NPC wizard in create or edit mode and reset step navigation.
      const openNpcWizard = ({ mode, npc = null } = {}) => {
        npcWizardState.step = 1;
        if (mode === "edit" && npc) {
          populateNpcForm(npc);
          npcModalTitle.textContent = "Edit NPC";
        } else {
          resetNpcForm("Add details for your new NPC, then confirm on the final step.");
          npcModalTitle.textContent = "Create NPC";
        }
        updateNpcWizardView();
        openModal(npcModal);
      };

      const resetNpcForm = (
        note = "Use the gallery to revisit NPCs and update their relationship status."
      ) => {
        npcForm.reset();
        // Restore select defaults that may not reset to desired gameplay-friendly values.
        npcRelationship.value = "Neutral";
        npcDisposition.value = "Neutral";
        npcSize.value = "Medium";
        npcState.editingNpcId = null;
        npcSubmit.textContent = "Create NPC";
        setNpcFormNote(note);
      };

      const populateNpcForm = (npc) => {
        npcName.value = npc.name;
        npcRole.value = npc.role ?? "";
        npcFaction.value = npc.faction ?? "";
        npcLocation.value = npc.location ?? "";
        npcAncestry.value = npc.ancestry ?? "";
        npcClass.value = npc.className ?? "";
        npcLevel.value = npc.level ?? "";
        npcAlignment.value = npc.alignment ?? "";
        npcSize.value = npc.size ?? "Medium";
        npcDisposition.value = npc.disposition ?? "Neutral";
        npcRelationship.value = npc.relationship ?? "Neutral";
        npcTags.value = npc.tags?.join(", ") ?? "";
        npcHp.value = npc.hitPoints ?? "";
        npcAc.value = npc.armorClass ?? "";
        npcSpeed.value = npc.speed ?? "";
        npcInitiative.value = npc.initiative ?? "";
        npcStrength.value = npc.attributes?.strength ?? "";
        npcDexterity.value = npc.attributes?.dexterity ?? "";
        npcConstitution.value = npc.attributes?.constitution ?? "";
        npcIntelligence.value = npc.attributes?.intelligence ?? "";
        npcWisdom.value = npc.attributes?.wisdom ?? "";
        npcCharisma.value = npc.attributes?.charisma ?? "";
        npcFortitude.value = npc.saves?.fortitude ?? "";
        npcReflex.value = npc.saves?.reflex ?? "";
        npcWill.value = npc.saves?.will ?? "";
        npcSenses.value = npc.senses ?? "";
        npcLanguages.value = npc.languages ?? "";
        npcHook.value = npc.hook ?? "";
        npcSkills.value = npc.skills ?? "";
        npcEquipment.value = npc.equipment ?? "";
        npcAbilities.value = npc.abilities ?? "";
        npcNotes.value = npc.notes ?? "";
        npcState.editingNpcId = npc.id;
        npcSubmit.textContent = "Update NPC";
        setNpcFormNote(`Editing "${npc.name}". Submit to save updates.`);
      };

      const persistNpcRoster = () => {
        updateNpcMemory((npcMemory) => ({
          ...npcMemory,
          roster: npcState.roster,
          activeNpcId: npcState.activeNpcId,
        }));
      };

      const renderNpcDetail = () => {
        const activeNpc = getNpcById(npcState.activeNpcId);
        if (!activeNpc) {
          npcDetail.innerHTML = '<p class="helper-text">Select an NPC to see their details here.</p>';
          return;
        }
        const tagsMarkup = activeNpc.tags?.length
          ? activeNpc.tags.map((tag) => `<span class="tool-tag">${tag}</span>`).join("")
          : '<span class="helper-text">No tags</span>';
        npcDetail.innerHTML = `
          <div class="npc-detail-item">
            <div class="npc-detail-label">Name</div>
            <div>${activeNpc.name}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Role & Faction</div>
            <div>${formatNpcField(activeNpc.role)} · ${formatNpcField(activeNpc.faction)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Location</div>
            <div>${formatNpcField(activeNpc.location)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Ancestry · Class · Level</div>
            <div>
              ${formatNpcField(activeNpc.ancestry)} · ${formatNpcField(activeNpc.className)} ·
              ${formatNpcField(activeNpc.level)}
            </div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Alignment & Size</div>
            <div>${formatNpcField(activeNpc.alignment)} · ${formatNpcField(activeNpc.size)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Disposition</div>
            <div>${formatNpcField(activeNpc.disposition)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Relationship</div>
            <div>${formatNpcField(activeNpc.relationship)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">HP · AC · Speed · Initiative</div>
            <div>
              ${formatNpcField(activeNpc.hitPoints)} · ${formatNpcField(activeNpc.armorClass)} ·
              ${formatNpcField(activeNpc.speed)} · ${formatNpcField(activeNpc.initiative)}
            </div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Attributes</div>
            <div>${formatNpcAttributes(activeNpc.attributes)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Saving Throws</div>
            <div>${formatNpcSaves(activeNpc.saves)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Senses & Languages</div>
            <div>${formatNpcField(activeNpc.senses)} · ${formatNpcField(activeNpc.languages)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Tags</div>
            <div class="tool-meta">${tagsMarkup}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Story Hook</div>
            <div>${formatNpcField(activeNpc.hook)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Skills & Proficiencies</div>
            <div>${formatNpcField(activeNpc.skills)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Equipment</div>
            <div>${formatNpcField(activeNpc.equipment)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Special Abilities</div>
            <div>${formatNpcField(activeNpc.abilities)}</div>
          </div>
          <div class="npc-detail-item">
            <div class="npc-detail-label">Roleplay Notes</div>
            <div>${formatNpcField(activeNpc.notes)}</div>
          </div>
        `;
      };

      const renderNpcList = () => {
        if (!npcState.roster.length) {
          npcList.innerHTML = "";
          npcEmptyState.classList.remove("is-hidden");
          renderNpcDetail();
          return;
        }
        npcEmptyState.classList.add("is-hidden");
        npcList.innerHTML = npcState.roster
          .map((npc) => {
            const isActive = npc.id === npcState.activeNpcId;
            const tags = npc.tags?.length
              ? npc.tags.map((tag) => `<span class="tool-tag">${tag}</span>`).join("")
              : '<span class="tool-tag">Un-tagged</span>';
            return `
              <article class="npc-gallery-card ${isActive ? "is-active" : ""}">
                <div class="npc-card__title">${npc.name}</div>
                <div class="npc-gallery-card__meta">
                  ${formatNpcField(npc.role, "No role")} · ${formatNpcField(npc.relationship, "Neutral")}
                </div>
                <div class="npc-gallery-card__meta">
                  ${formatNpcField(npc.location, "No location")} · ${formatNpcField(npc.faction, "No faction")}
                </div>
                <div class="npc-gallery-card__tags">${tags}</div>
                <div class="npc-gallery-card__actions">
                  <button type="button" class="secondary" data-npc-view="${npc.id}">View</button>
                  <button type="button" class="ghost" data-npc-edit="${npc.id}">Edit</button>
                  <button type="button" data-npc-delete="${npc.id}">Archive</button>
                </div>
              </article>
            `;
          })
          .join("");
        renderNpcDetail();
      };

      const renderNpcModule = () => {
        const npcMemory = getNpcMemory();
        npcState.roster = npcMemory.roster ?? [];
        npcState.activeNpcId = npcMemory.activeNpcId ?? npcState.roster[0]?.id ?? null;
        npcState.editingNpcId = null;
        resetNpcForm();
        setNpcWizardStep(1);
        renderNpcList();
      };

      // Creature memory helpers persist roster data between sessions.
      const getCreatureMemory = () => {
        const stored = localStorage.getItem("pf-creature-library-v1");
        if (!stored) {
          return { roster: [], activeCreatureId: null };
        }
        try {
          return JSON.parse(stored);
        } catch (error) {
          console.warn("Creature library data was malformed, clearing storage.", error);
          return { roster: [], activeCreatureId: null };
        }
      };

      const persistCreatureLibrary = () => {
        localStorage.setItem(
          "pf-creature-library-v1",
          JSON.stringify({
            roster: creatureState.roster,
            activeCreatureId: creatureState.activeCreatureId,
          })
        );
      };

      // Provide consistent fallback formatting for creature stat blocks.
      const formatCreatureField = (value, fallback = "—") => (value && value.trim() ? value.trim() : fallback);

      const getCreatureById = (creatureId) =>
        creatureState.roster.find((creature) => creature.id === creatureId) ?? null;

      const buildCreaturePayload = (overrides = {}) => ({
        id: overrides.id ?? generateId(),
        name: creatureName.value.trim(),
        level: creatureLevel.value.trim(),
        role: creatureRole.value.trim(),
        traits: creatureTraits.value.trim(),
        alignment: creatureAlignment.value.trim(),
        size: creatureSize.value.trim(),
        perception: creaturePerception.value.trim(),
        senses: creatureSenses.value.trim(),
        languages: creatureLanguages.value.trim(),
        ac: creatureAc.value.trim(),
        hp: creatureHp.value.trim(),
        fortitude: creatureFortitude.value.trim(),
        reflex: creatureReflex.value.trim(),
        will: creatureWill.value.trim(),
        resistances: creatureResistances.value.trim(),
        weaknesses: creatureWeaknesses.value.trim(),
        immunities: creatureImmunities.value.trim(),
        speed: creatureSpeed.value.trim(),
        melee: creatureMelee.value.trim(),
        ranged: creatureRanged.value.trim(),
        abilities: creatureAbilities.value.trim(),
        skills: creatureSkills.value.trim(),
        notes: creatureNotes.value.trim(),
        updatedAt: new Date().toISOString(),
        ...overrides,
      });

      // Clear the creature form while providing an optional status message.
      const resetCreatureForm = (message = "Ready to capture a new creature profile.") => {
        creatureForm.reset();
        creatureState.editingCreatureId = null;
        creatureFormTitle.textContent = "Create Creature";
        creatureFormNote.textContent = message;
      };

      // Fill the creature form with data when editing an existing entry.
      const hydrateCreatureForm = (creature) => {
        creatureName.value = creature.name ?? "";
        creatureLevel.value = creature.level ?? "";
        creatureRole.value = creature.role ?? "";
        creatureTraits.value = creature.traits ?? "";
        creatureAlignment.value = creature.alignment ?? "";
        creatureSize.value = creature.size ?? "";
        creaturePerception.value = creature.perception ?? "";
        creatureSenses.value = creature.senses ?? "";
        creatureLanguages.value = creature.languages ?? "";
        creatureAc.value = creature.ac ?? "";
        creatureHp.value = creature.hp ?? "";
        creatureFortitude.value = creature.fortitude ?? "";
        creatureReflex.value = creature.reflex ?? "";
        creatureWill.value = creature.will ?? "";
        creatureResistances.value = creature.resistances ?? "";
        creatureWeaknesses.value = creature.weaknesses ?? "";
        creatureImmunities.value = creature.immunities ?? "";
        creatureSpeed.value = creature.speed ?? "";
        creatureMelee.value = creature.melee ?? "";
        creatureRanged.value = creature.ranged ?? "";
        creatureAbilities.value = creature.abilities ?? "";
        creatureSkills.value = creature.skills ?? "";
        creatureNotes.value = creature.notes ?? "";
        creatureFormTitle.textContent = `Edit Creature: ${creature.name}`;
        creatureFormNote.textContent = "Update combat essentials and save to refresh the stat cards.";
      };

      // Update the selection counter and export button state in the UI.
      const updateCreatureSelectionCount = () => {
        const count = creatureState.selectedCreatureIds.size;
        creatureSelectionCount.textContent = `${count} creature${count === 1 ? "" : "s"} selected.`;
        const hasSelection = count > 0;
        creatureExportSelected.disabled = !hasSelection;
        creatureExport.disabled = !hasSelection;
      };

      const renderCreatureList = () => {
        if (!creatureState.roster.length) {
          creatureList.innerHTML = "";
          creatureEmptyState.classList.remove("is-hidden");
          updateCreatureSelectionCount();
          return;
        }
        creatureEmptyState.classList.add("is-hidden");
        creatureList.innerHTML = creatureState.roster
          .map((creature) => {
            const isActive = creature.id === creatureState.activeCreatureId;
            const isSelected = creatureState.selectedCreatureIds.has(creature.id);
            const meta = [
              formatCreatureField(creature.level, "Level —"),
              formatCreatureField(creature.role, "Role —"),
            ].join(" · ");
            const descriptors = [
              formatCreatureField(creature.size, "Size —"),
              formatCreatureField(creature.traits, "Traits —"),
            ].join(" · ");
            return `
              <article class="creature-card ${isActive ? "is-active" : ""}">
                <div class="creature-card__title">
                  <span>${creature.name || "Unnamed Creature"}</span>
                  <label>
                    <input
                      type="checkbox"
                      ${isSelected ? "checked" : ""}
                      data-creature-select="${creature.id}"
                    />
                    Select
                  </label>
                </div>
                <div class="creature-card__meta">${meta}</div>
                <div class="creature-card__meta">${descriptors}</div>
                <div class="creature-card__actions">
                  <button type="button" class="secondary" data-creature-edit="${creature.id}">
                    Edit
                  </button>
                  <button type="button" class="ghost" data-creature-duplicate="${creature.id}">
                    Duplicate
                  </button>
                  <button type="button" data-creature-delete="${creature.id}">
                    Delete
                  </button>
                </div>
              </article>
            `;
          })
          .join("");
        updateCreatureSelectionCount();
      };

      // Provide a simple statblock parser for quick creature entry.
      const parseCreatureStatblock = (text) => {
        // Normalize lines while keeping section breaks intact for reliable parsing.
        const normalizedText = text.replace(/\r/g, "").trim();
        const lines = normalizedText
          .split("\n")
          .map((line) => line.trim())
          .filter(Boolean);
        const parsed = {};
        const sectionHeaders = ["Defense", "Offense", "Statistics", "Ecology", "Special Abilities"];
        const sectionRegex = new RegExp(`^(${sectionHeaders.join("|")})$`, "i");

        // Extract the creature name and level/CR from the first line when possible.
        if (lines.length) {
          const nameMatch = lines[0].match(/^(.*?)(?:\s+(?:CR|Level)\s*([\d/+.]+))?$/i);
          if (nameMatch) {
            parsed.name = nameMatch[1]?.trim() ?? "";
            if (nameMatch[2]) {
              parsed.level = nameMatch[2].trim();
            }
          }
        }

        // Capture alignment, size, and type from the identity line (e.g., "CE Medium humanoid (dark folk)").
        const alignmentPattern = /(LG|NG|CG|LN|N|CN|LE|NE|CE)/i;
        const sizePattern = /(Fine|Diminutive|Tiny|Small|Medium|Large|Huge|Gargantuan|Colossal)/i;
        const identityLine = lines.find(
          (line) => alignmentPattern.test(line) && sizePattern.test(line)
        );
        if (identityLine) {
          const identityMatch = identityLine.match(
            /^(LG|NG|CG|LN|N|CN|LE|NE|CE)\s+(Fine|Diminutive|Tiny|Small|Medium|Large|Huge|Gargantuan|Colossal)\s+(.+)$/i
          );
          if (identityMatch) {
            parsed.alignment = identityMatch[1];
            parsed.size = identityMatch[2];
            parsed.traits = identityMatch[3];
          }
        }

        // Helper to capture labels with flexible terminators (useful for semicolons inside stat lines).
        const captureLineValue = (label, pattern = "[^\\n]+") => {
          const match = normalizedText.match(new RegExp(`(?:${label})\\s*(${pattern})`, "i"));
          return match?.[1]?.trim() ?? "";
        };

        // Sections keep grouped content like spell-like abilities or special abilities together.
        const getSectionLines = (header) => {
          const startIndex = lines.findIndex((line) => line.toLowerCase() === header.toLowerCase());
          if (startIndex === -1) {
            return [];
          }
          const following = lines.slice(startIndex + 1);
          const nextHeaderIndex = following.findIndex((line) => sectionRegex.test(line));
          const endIndex = nextHeaderIndex === -1 ? lines.length : startIndex + 1 + nextHeaderIndex;
          return lines.slice(startIndex + 1, endIndex);
        };

        parsed.ac = captureLineValue("AC");
        parsed.hp = captureLineValue("hp");
        parsed.fortitude = captureLineValue("Fort", "[^,;\\n]+");
        parsed.reflex = captureLineValue("Ref", "[^,;\\n]+");
        parsed.will = captureLineValue("Will", "[^,;\\n]+");
        parsed.weaknesses = captureLineValue("Weaknesses", "[^;\\n]+");
        parsed.resistances = captureLineValue("Resist(?:ances)?", "[^;\\n]+");
        parsed.immunities = captureLineValue("Immune|Immunities", "[^;\\n]+");

        parsed.perception = captureLineValue("Perception", "[^;\\n]+");
        parsed.senses = captureLineValue("Senses", "[^;\\n]+");
        parsed.languages = captureLineValue("Languages");
        parsed.speed = captureLineValue("Speed", "[^;\\n]+");
        parsed.melee = captureLineValue("Melee", "[^\\n]+");
        parsed.ranged = captureLineValue("Ranged", "[^\\n]+");

        // Parse offense extras (spell-like abilities, special attacks, etc.) into the abilities field.
        const offenseLines = getSectionLines("Offense");
        const offenseExtras = offenseLines.filter(
          (line) => !/^(Speed|Melee|Ranged)\b/i.test(line)
        );

        // Parse statistics details into the skills field for quick lookup during play.
        const statisticsLines = getSectionLines("Statistics");
        const abilityScoresLine = statisticsLines.find((line) => /Str\s*\d+/i.test(line));
        const baseAttackLine = statisticsLines.find((line) => /^Base Atk\b/i.test(line));
        const featsLine = statisticsLines.find((line) => /^Feats\b/i.test(line));
        const skillsLine = statisticsLines.find((line) => /^Skills\b/i.test(line));
        const sqLine = statisticsLines.find((line) => /^SQ\b/i.test(line));

        const skillsSummary = [abilityScoresLine, skillsLine].filter(Boolean);

        if (skillsSummary.length) {
          parsed.skills = skillsSummary.join("\n");
        }

        // Capture special ability text blocks for combat-ready notes.
        const specialAbilitiesLines = getSectionLines("Special Abilities");
        const ecologyLines = getSectionLines("Ecology");

        const abilitiesSummary = [...offenseExtras, ...specialAbilitiesLines].filter(Boolean);
        if (abilitiesSummary.length) {
          parsed.abilities = abilitiesSummary.join("\n");
        }

        const notesSummary = [
          lines.find((line) => /^Source\b/i.test(line)),
          lines.find((line) => /^XP\b/i.test(line)),
          baseAttackLine,
          featsLine,
          sqLine,
          ...ecologyLines,
        ].filter(Boolean);
        if (notesSummary.length) {
          parsed.notes = notesSummary.join("\n");
        }

        return parsed;
      };

      // Apply parsed statblock data to the creature form fields.
      const applyCreatureParse = (parsed) => {
        creatureName.value = parsed.name ?? creatureName.value;
        creatureLevel.value = parsed.level ?? creatureLevel.value;
        creatureTraits.value = parsed.traits ?? creatureTraits.value;
        creatureAlignment.value = parsed.alignment ?? creatureAlignment.value;
        creatureSize.value = parsed.size ?? creatureSize.value;
        creaturePerception.value = parsed.perception ?? creaturePerception.value;
        creatureSenses.value = parsed.senses ?? creatureSenses.value;
        creatureLanguages.value = parsed.languages ?? creatureLanguages.value;
        creatureAc.value = parsed.ac ?? creatureAc.value;
        creatureHp.value = parsed.hp ?? creatureHp.value;
        creatureFortitude.value = parsed.fortitude ?? creatureFortitude.value;
        creatureReflex.value = parsed.reflex ?? creatureReflex.value;
        creatureWill.value = parsed.will ?? creatureWill.value;
        creatureResistances.value = parsed.resistances ?? creatureResistances.value;
        creatureWeaknesses.value = parsed.weaknesses ?? creatureWeaknesses.value;
        creatureImmunities.value = parsed.immunities ?? creatureImmunities.value;
        creatureSpeed.value = parsed.speed ?? creatureSpeed.value;
        creatureMelee.value = parsed.melee ?? creatureMelee.value;
        creatureRanged.value = parsed.ranged ?? creatureRanged.value;
        creatureAbilities.value = parsed.abilities ?? creatureAbilities.value;
        creatureSkills.value = parsed.skills ?? creatureSkills.value;
        creatureNotes.value = parsed.notes ?? creatureNotes.value;
      };

      // Wrap text at a rough character limit for card rendering.
      const wrapCardText = (text, maxChars) => {
        if (!text) {
          return [];
        }
        const words = text.split(/\s+/).filter(Boolean);
        const lines = [];
        let current = "";
        words.forEach((word) => {
          if (`${current} ${word}`.trim().length > maxChars) {
            if (current) {
              lines.push(current);
            }
            current = word;
            return;
          }
          current = `${current} ${word}`.trim();
        });
        if (current) {
          lines.push(current);
        }
        return lines;
      };

      // Escape text for HTML injection safety in generated print windows.
      const escapeHtml = (value) =>
        value
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");

      const buildCreatureCardLines = (creature, maxChars) => {
        const sections = [];
        const addSection = (title, content) => {
          if (!content || !content.trim()) {
            return;
          }
          sections.push({
            title,
            lines: wrapCardText(content, maxChars),
          });
        };

        addSection(
          "Defense",
          [
            creature.ac ? `AC ${creature.ac}` : "",
            creature.hp ? `HP ${creature.hp}` : "",
            creature.fortitude ? `Fort ${creature.fortitude}` : "",
            creature.reflex ? `Ref ${creature.reflex}` : "",
            creature.will ? `Will ${creature.will}` : "",
            creature.resistances ? `Resist ${creature.resistances}` : "",
            creature.weaknesses ? `Weak ${creature.weaknesses}` : "",
            creature.immunities ? `Immune ${creature.immunities}` : "",
          ]
            .filter(Boolean)
            .join("; ")
        );

        addSection(
          "Offense",
          [
            creature.speed ? `Speed ${creature.speed}` : "",
            creature.melee ? `Melee ${creature.melee}` : "",
            creature.ranged ? `Ranged ${creature.ranged}` : "",
          ]
            .filter(Boolean)
            .join("; ")
        );

        addSection("Special", creature.abilities);
        addSection("Skills", creature.skills);
        addSection("Notes", creature.notes);

        return sections.flatMap((section) => [
          { text: section.title, isTitle: true },
          ...section.lines.map((line) => ({ text: line, isTitle: false })),
        ]);
      };

      // Build printable HTML for a creature's stat cards, splitting into multiple cards as needed.
      const buildCreatureCardHtml = (creature) => {
        const maxChars = 36;
        const maxLines = 18;
        const headerLines = [
          creature.name || "Unnamed Creature",
          [
            creature.level ? `Level/CR ${creature.level}` : "",
            creature.role,
            creature.traits,
            creature.size,
            creature.alignment,
          ]
            .filter((value) => value && value.trim())
            .join(" · "),
          [creature.perception ? `Perception ${creature.perception}` : "", creature.senses]
            .filter((value) => value && value.trim())
            .join(" · "),
        ].filter((line) => line && line.trim());

        const lines = buildCreatureCardLines(creature, maxChars);
        const cards = [];
        let index = 0;

        if (!lines.length) {
          cards.push({
            headerLines,
            lines: [{ text: "No combat data provided.", isTitle: false }],
          });
        }

        while (index < lines.length) {
          const available = maxLines - headerLines.length;
          const pageLines = [];
          while (pageLines.length < available && index < lines.length) {
            const current = lines[index];
            const remainingSlots = available - pageLines.length;
            if (current.isTitle && remainingSlots === 1 && index + 1 < lines.length) {
              break;
            }
            pageLines.push(current);
            index += 1;
          }
          cards.push({ headerLines, lines: pageLines });
        }

        return cards
          .map(
            (card) => `
              <div class="stat-card">
                <div class="stat-card__header">
                  ${card.headerLines
                    .map((line, lineIndex) =>
                      lineIndex === 0
                        ? `<div class="stat-card__name">${escapeHtml(line)}</div>`
                        : `<div class="stat-card__meta">${escapeHtml(line)}</div>`
                    )
                    .join("")}
                </div>
                <div class="stat-card__body">
                  ${card.lines
                    .map((line) =>
                      line.isTitle
                        ? `<div class="stat-card__line stat-card__line--title">${escapeHtml(
                            line.text
                          )}</div>`
                        : `<div class="stat-card__line">${escapeHtml(line.text)}</div>`
                    )
                    .join("")}
                </div>
              </div>
            `
          )
          .join("");
      };

      // Open a print window with card-sized pages so browsers can export PDF.
      const exportCreatureCards = (creatures) => {
        const cardMarkup = creatures.map((creature) => buildCreatureCardHtml(creature)).join("");
        const printWindow = window.open("", "_blank");
        if (!printWindow) {
          creatureFormNote.textContent = "Pop-up blocked. Allow pop-ups to export cards to PDF.";
          return;
        }
        printWindow.document.write(`
          <!DOCTYPE html>
          <html lang="en">
            <head>
              <meta charset="UTF-8" />
              <title>Creature Stat Cards</title>
              <style>
                @page {
                  size: letter;
                  margin: 8mm;
                }
                * {
                  box-sizing: border-box;
                }
                body {
                  /* Multi-card grid with cut-friendly spacing for printable sheets. */
                  margin: 0;
                  padding: 0;
                  display: grid;
                  gap: 4mm;
                  grid-template-columns: repeat(auto-fill, 63mm);
                  justify-content: start;
                  align-content: start;
                  font-family: "Trebuchet MS", "Segoe UI", sans-serif;
                }
                .stat-card {
                  width: 63mm;
                  height: 88mm;
                  padding: 4mm;
                  border: 1px solid #3b2f21;
                  border-radius: 8px;
                  display: flex;
                  flex-direction: column;
                  gap: 2mm;
                  background: linear-gradient(165deg, #fff7e8 0%, #f1e1c2 100%);
                  box-shadow: 0 3mm 5mm rgba(20, 14, 8, 0.25);
                  position: relative;
                  overflow: hidden;
                  break-inside: avoid;
                  page-break-inside: avoid;
                }
                .stat-card__header {
                  border-bottom: 1px solid rgba(59, 47, 33, 0.7);
                  padding-bottom: 1mm;
                  display: grid;
                  gap: 0.8mm;
                }
                .stat-card__name {
                  font-weight: 700;
                  font-size: 11pt;
                  text-transform: uppercase;
                  letter-spacing: 0.08em;
                }
                .stat-card__meta {
                  font-size: 8.5pt;
                  color: #4c3d2a;
                }
                .stat-card__body {
                  display: grid;
                  gap: 1mm;
                  font-size: 8pt;
                  line-height: 1.2;
                  color: #14100c;
                  text-wrap: pretty;
                }
                .stat-card__line--title {
                  font-weight: 700;
                  text-transform: uppercase;
                  letter-spacing: 0.06em;
                  margin-top: 0.6mm;
                }
                .stat-card::before {
                  content: "";
                  position: absolute;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 4mm;
                  background: linear-gradient(90deg, #7a1414 0%, #c9a24a 100%);
                  opacity: 0.9;
                }
                .stat-card__header,
                .stat-card__body {
                  position: relative;
                  z-index: 1;
                }
                @media print {
                  body {
                    -webkit-print-color-adjust: exact;
                    print-color-adjust: exact;
                  }
                }
              </style>
            </head>
            <body>
              ${cardMarkup}
            </body>
          </html>
        `);
        printWindow.document.close();
        printWindow.focus();
        printWindow.print();
      };

      // Render creature roster data into the module view on entry.
      const renderCreatureModule = () => {
        const creatureMemory = getCreatureMemory();
        creatureState.roster = creatureMemory.roster ?? [];
        creatureState.activeCreatureId = creatureMemory.activeCreatureId ?? creatureState.roster[0]?.id ?? null;
        creatureState.editingCreatureId = null;
        creatureState.selectedCreatureIds = new Set();
        resetCreatureForm();
        renderCreatureList();
      };

      // Format timestamps for human-friendly session status updates.
      const formatSessionTimestamp = (timestamp) => {
        if (!timestamp) {
          return "—";
        }
        const date = new Date(timestamp);
        if (Number.isNaN(date.getTime())) {
          return "—";
        }
        return date.toLocaleString();
      };

      // Update the inline status message shown beneath session actions.
      const updateSessionStatusNote = (message) => {
        sessionStatusNote.textContent = message;
      };

      // Keep the last-saved label aligned with persisted data.
      const updateSessionLastSaved = (timestamp) => {
        sessionLastSaved.textContent = `Last saved: ${formatSessionTimestamp(timestamp)}`;
      };

      // Normalize summary copy so empty entries read as placeholders.
      const formatSessionSummary = (value) => (value && value.trim() ? value.trim() : "—");

      // Update summary blocks that surface prep/run details in later views.
      const updateSessionSummaries = (note) => {
        const prep = note.prep ?? {};
        const run = note.run ?? {};
        sessionSummaryGoal.textContent = formatSessionSummary(note.goal ?? "");
        sessionSummaryPriorities.textContent = formatSessionSummary(prep.priorities ?? "");
        sessionSummaryScenes.textContent = formatSessionSummary(prep.scenes ?? "");
        sessionSummaryNpcs.textContent = formatSessionSummary(prep.npcs ?? "");
        sessionSummaryLocations.textContent = formatSessionSummary(prep.locations ?? "");
        sessionSummaryEncounters.textContent = formatSessionSummary(prep.encounters ?? "");
        sessionSummaryHandouts.textContent = formatSessionSummary(prep.handouts ?? "");
        sessionSummaryRisks.textContent = formatSessionSummary(prep.risks ?? "");
        sessionSummaryContingencies.textContent = formatSessionSummary(prep.contingencies ?? "");
        sessionSummaryReviewGoal.textContent = formatSessionSummary(note.goal ?? "");
        sessionSummaryReviewScenes.textContent = formatSessionSummary(prep.scenes ?? "");
        sessionSummaryReviewNpcs.textContent = formatSessionSummary(prep.npcs ?? "");
        sessionSummaryReviewLog.textContent = formatSessionSummary(run.log ?? "");
        sessionSummaryReviewRulings.textContent = formatSessionSummary(run.rulings ?? "");
        sessionSummaryReviewLoot.textContent = formatSessionSummary(run.loot ?? "");
        sessionSummaryReviewMoments.textContent = formatSessionSummary(run.moments ?? "");
        sessionSummaryReviewPacing.textContent = formatSessionSummary(run.pacing ?? "");
      };

      // Update the session header to reflect the active timeline entry.
      const updateSessionHeader = (note) => {
        const title = note.title?.trim() || "Untitled Session";
        const number = note.number?.trim() ? `Session ${note.number.trim()}` : "Session";
        const date = note.date ? new Date(note.date).toLocaleDateString() : "Date TBD";
        const location = note.location?.trim() || "Location TBD";
        sessionActiveTitle.textContent = title;
        sessionActiveMeta.textContent = `${number} · ${date} · ${location}`;
      };

      // Keep summary blocks aligned with the in-progress form values.
      const syncSessionPreview = () => {
        const activeSession = getActiveSession() ?? createSessionEntry();
        const preview = createSessionEntry({
          ...activeSession,
          ...getSessionFormData(),
          id: activeSession.id ?? generateId(),
        });
        updateSessionSummaries(preview);
        updateSessionHeader(preview);
      };

      // Read the current session form values into a structured payload.
      const getSessionFormData = () => ({
        title: sessionTitle.value.trim(),
        number: sessionNumber.value.trim(),
        date: sessionDate.value,
        location: sessionLocation.value.trim(),
        status: sessionStatus.value,
        tags: sessionTags.value.trim(),
        goal: sessionGoal.value.trim(),
        prep: {
          priorities: sessionPrepPriorities.value.trim(),
          scenes: sessionPrepScenes.value.trim(),
          npcs: sessionPrepNpcs.value.trim(),
          locations: sessionPrepLocations.value.trim(),
          encounters: sessionPrepEncounters.value.trim(),
          handouts: sessionPrepHandouts.value.trim(),
          risks: sessionPrepRisks.value.trim(),
          contingencies: sessionPrepContingencies.value.trim(),
        },
        run: {
          recap: sessionRunRecap.value.trim(),
          log: sessionRunLog.value.trim(),
          rulings: sessionRunRulings.value.trim(),
          loot: sessionRunLoot.value.trim(),
          moments: sessionRunMoments.value.trim(),
          pacing: sessionRunPacing.value.trim(),
          pinned: sessionRunPinned.value.trim(),
          spotlights: sessionRunSpotlights.value.trim(),
          questions: sessionRunQuestions.value.trim(),
          conditions: sessionRunConditions.value.trim(),
        },
        review: {
          outcomes: sessionReviewOutcomes.value.trim(),
          looseEnds: sessionReviewLooseEnds.value.trim(),
          next: sessionReviewNext.value.trim(),
          feedback: sessionReviewFeedback.value.trim(),
          rewards: sessionReviewRewards.value.trim(),
          improvements: sessionReviewImprovements.value.trim(),
        },
      });

      // Hydrate the session notes form with saved values.
      const hydrateSessionForm = (note) => {
        const prep = note.prep ?? {};
        const run = note.run ?? {};
        const review = note.review ?? {};
        sessionTitle.value = note.title ?? "";
        sessionNumber.value = note.number ?? "";
        sessionDate.value = note.date ?? "";
        sessionLocation.value = note.location ?? "";
        sessionStatus.value = note.status ?? "prep";
        sessionTags.value = note.tags ?? "";
        sessionGoal.value = note.goal ?? "";
        sessionPrepPriorities.value = prep.priorities ?? "";
        sessionPrepScenes.value = prep.scenes ?? "";
        sessionPrepNpcs.value = prep.npcs ?? "";
        sessionPrepLocations.value = prep.locations ?? "";
        sessionPrepEncounters.value = prep.encounters ?? "";
        sessionPrepHandouts.value = prep.handouts ?? "";
        sessionPrepRisks.value = prep.risks ?? "";
        sessionPrepContingencies.value = prep.contingencies ?? "";
        sessionRunRecap.value = run.recap ?? "";
        sessionRunLog.value = run.log ?? "";
        sessionRunRulings.value = run.rulings ?? "";
        sessionRunLoot.value = run.loot ?? "";
        sessionRunMoments.value = run.moments ?? "";
        sessionRunPacing.value = run.pacing ?? "";
        sessionRunPinned.value = run.pinned ?? "";
        sessionRunSpotlights.value = run.spotlights ?? "";
        sessionRunQuestions.value = run.questions ?? "";
        sessionRunConditions.value = run.conditions ?? "";
        sessionReviewOutcomes.value = review.outcomes ?? "";
        sessionReviewLooseEnds.value = review.looseEnds ?? "";
        sessionReviewNext.value = review.next ?? "";
        sessionReviewFeedback.value = review.feedback ?? "";
        sessionReviewRewards.value = review.rewards ?? "";
        sessionReviewImprovements.value = review.improvements ?? "";
        updateSessionLastSaved(note.lastSaved);
        updateSessionSummaries(note);
        updateSessionHeader(note);
      };

      // Return the active session object from the timeline state.
      const getActiveSession = () =>
        sessionState.sessions.find((session) => session.id === sessionState.activeSessionId) ?? null;

      // Persist the session timeline state to local storage.
      const persistSessionState = () => {
        updateSessionMemory((sessionMemory) => ({
          ...sessionMemory,
          sessions: sessionState.sessions,
          activeSessionId: sessionState.activeSessionId,
        }));
      };

      // Persist the active session to local storage with a timestamp.
      const saveSessionNote = ({ announce = true } = {}) => {
        const activeSession = getActiveSession();
        if (!activeSession) {
          return;
        }
        const payload = createSessionEntry({
          ...activeSession,
          ...getSessionFormData(),
          lastSaved: new Date().toISOString(),
        });
        sessionState.sessions = sessionState.sessions.map((session) =>
          session.id === activeSession.id ? payload : session
        );
        persistSessionState();
        updateSessionLastSaved(payload.lastSaved);
        updateSessionSummaries(payload);
        updateSessionHeader(payload);
        renderSessionTimeline();
        updateSessionStatusNote(announce ? "Session notes saved." : "Auto-saved.");
      };

      // Reset the active session note to a clean slate while persisting the clear action.
      const resetSessionNote = () => {
        const activeSession = getActiveSession();
        if (!activeSession) {
          return;
        }
        const cleared = createSessionEntry({
          ...defaultSessionEntryData(),
          id: activeSession.id,
          lastSaved: new Date().toISOString(),
        });
        sessionState.sessions = sessionState.sessions.map((session) =>
          session.id === activeSession.id ? cleared : session
        );
        persistSessionState();
        hydrateSessionForm(cleared);
        updateSessionStatusNote("Session notes cleared.");
        renderSessionTimeline();
      };

      // Queue an auto-save to keep the UI responsive and unobtrusive.
      const queueSessionAutoSave = () => {
        syncSessionPreview();
        window.clearTimeout(sessionState.autoSaveTimer);
        sessionState.autoSaveTimer = window.setTimeout(() => {
          saveSessionNote({ announce: false });
        }, 900);
      };

      // Update the visible view section for prep/run/review.
      const setSessionView = (view) => {
        sessionState.activeView = view;
        sessionViewSections.forEach((section) => {
          section.classList.toggle("is-active", section.dataset.sessionView === view);
        });
      };

      // Update the active session selection and refresh form content.
      const setActiveSession = (sessionId, view) => {
        sessionState.activeSessionId = sessionId;
        if (view) {
          setSessionView(view);
        }
        persistSessionState();
        const activeSession = getActiveSession();
        if (activeSession) {
          hydrateSessionForm(activeSession);
        }
        renderSessionTimeline();
      };

      // Render the session timeline cards with view toggles.
      const renderSessionTimeline = () => {
        if (!sessionTimelineList) {
          return;
        }
        sessionTimelineList.innerHTML = sessionState.sessions
          .map((session) => {
            const isActive = session.id === sessionState.activeSessionId;
            const numberLabel = session.number?.trim() ? `Session ${session.number}` : "Session";
            const dateLabel = session.date ? new Date(session.date).toLocaleDateString() : "Date TBD";
            return `
              <article class="session-timeline-card ${isActive ? "is-active" : ""}">
                <div class="session-timeline-title">${session.title || "Untitled Session"}</div>
                <div class="session-timeline-meta">${numberLabel} · ${dateLabel}</div>
                <div class="session-timeline-meta">${session.location || "Location TBD"}</div>
                <div class="session-timeline-actions">
                  <button type="button" class="secondary" data-session-id="${session.id}" data-session-view="prep">
                    Prep
                  </button>
                  <button type="button" class="ghost" data-session-id="${session.id}" data-session-view="run">
                    Run
                  </button>
                  <button type="button" data-session-id="${session.id}" data-session-view="review">
                    Review
                  </button>
                </div>
              </article>
            `;
          })
          .join("");
      };

      // Load the saved session timeline when entering the module.
      const renderSessionModule = () => {
        const sessionMemory = getSessionMemory();
        sessionState.sessions = sessionMemory.sessions?.map((session) => createSessionEntry(session)) ?? [];
        sessionState.activeSessionId = sessionMemory.activeSessionId ?? sessionState.sessions[0]?.id ?? null;
        setSessionView(sessionState.activeView || "prep");
        if (sessionState.sessions.length === 0) {
          sessionState.sessions = createSeedSessions();
          sessionState.activeSessionId = sessionState.sessions[0]?.id ?? null;
        }
        renderSessionTimeline();
        const activeSession = getActiveSession();
        if (activeSession) {
          hydrateSessionForm(activeSession);
          updateSessionStatusNote(
            activeSession.lastSaved ? "Session notes loaded." : "Not saved yet."
          );
        }
      };

      const openModal = (modal) => {
        modal.classList.add("active");
        modal.setAttribute("aria-hidden", "false");
      };

      const closeModal = (modal) => {
        modal.classList.remove("active");
        modal.setAttribute("aria-hidden", "true");
      };

      // Toggle module visibility to keep focused tools off the dashboard view.
      const hideModules = () => {
        initiativeModule.classList.add("is-hidden");
        npcModule.classList.add("is-hidden");
        creatureModule.classList.add("is-hidden");
        sessionModule.classList.add("is-hidden");
      };

      const openInitiativeModule = () => {
        hideModules();
        dashboardView.classList.add("is-hidden");
        initiativeModule.classList.remove("is-hidden");
        updateHeader("initiative");
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      const closeInitiativeModule = () => {
        initiativeModule.classList.add("is-hidden");
        dashboardView.classList.remove("is-hidden");
        updateHeader("dashboard");
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      const openNpcModule = () => {
        hideModules();
        dashboardView.classList.add("is-hidden");
        npcModule.classList.remove("is-hidden");
        updateHeader("npc");
        renderNpcModule();
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      const closeNpcModule = () => {
        npcModule.classList.add("is-hidden");
        dashboardView.classList.remove("is-hidden");
        updateHeader("dashboard");
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      const openCreatureModule = () => {
        hideModules();
        dashboardView.classList.add("is-hidden");
        creatureModule.classList.remove("is-hidden");
        updateHeader("creature");
        renderCreatureModule();
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      const closeCreatureModule = () => {
        creatureModule.classList.add("is-hidden");
        dashboardView.classList.remove("is-hidden");
        updateHeader("dashboard");
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      const openSessionModule = () => {
        hideModules();
        dashboardView.classList.add("is-hidden");
        sessionModule.classList.remove("is-hidden");
        updateHeader("session");
        renderSessionModule();
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      const closeSessionModule = () => {
        sessionModule.classList.add("is-hidden");
        dashboardView.classList.remove("is-hidden");
        updateHeader("dashboard");
        window.scrollTo({ top: 0, behavior: "smooth" });
      };

      const getCurrentParticipant = () => state.participants[state.turnIndex] || null;

      const getCurrentTurnNumber = () => {
        const total = state.participants.length || 1;
        return (state.round - 1) * total + state.turnIndex;
      };

      const getNextTurnNumberForParticipant = (participantId) => {
        const total = state.participants.length || 1;
        const index = state.participants.findIndex((participant) => participant.id === participantId);
        if (index < 0) {
          return getCurrentTurnNumber();
        }
        const currentTurnNumber = getCurrentTurnNumber();
        const currentRoundIndex = state.turnIndex;
        if (index >= currentRoundIndex) {
          return (state.round - 1) * total + index;
        }
        return state.round * total + index;
      };

      const updateEncounterControls = () => {
        const hasParticipants = state.participants.length > 0;
        startEncounterButton.disabled = !hasParticipants;
        rewardEncounterButton.disabled = !state.encounterStarted || !hasParticipants;
        nextTurnButton.disabled = !state.encounterStarted;
        previousTurnButton.disabled = !state.encounterStarted;
        encounterStatus.classList.toggle("is-hidden", !state.encounterStarted);
        rewardStatus.classList.toggle("is-hidden", !state.rewardsGranted);
      };

      const updateRoundDisplay = () => {
        roundCount.textContent = state.round;
        const current = getCurrentParticipant();
        currentParticipantLabel.textContent = current
          ? `${current.name} (${current.type})`
          : "Awaiting initiative...";
      };

      const updateEncounterSummary = () => {
        const summary = getEncounterSummary();
        encounterCrValue.textContent = summary.encounterCr;
        totalXpValue.textContent = formatXp(summary.totalXp);
        xpPerPlayerValue.textContent = formatXp(summary.xpPerPlayer);
      };

      const updateMarkerSelects = () => {
        const options = state.participants
          .map((participant) => `<option value="${participant.id}">${participant.name}</option>`)
          .join("");
        markerTarget.innerHTML = options;
        markerStart.innerHTML = options;
      };

      const seedChallengeRatings = () => {
        participantCr.innerHTML = challengeRatings
          .map((rating) => `<option value="${rating.value}">CR ${rating.label} (${formatXp(rating.xp)} XP)</option>`)
          .join("");
      };

      const updateParticipantCrVisibility = () => {
        const showCr = isMonsterType(participantType.value);
        participantCrField.classList.toggle("is-hidden", !showCr);
        if (showCr && !participantCr.value) {
          participantCr.value = challengeRatings[0]?.value ?? "";
        }
      };

      const formatCrXp = (participant) => {
        if (!isMonsterType(participant.type)) {
          return "—";
        }
        if (!participant.challengeRating) {
          return "CR —";
        }
        const xp = getXpForChallengeRating(participant.challengeRating);
        return `CR ${participant.challengeRating} (${formatXp(xp)} XP)`;
      };

      // Render the encounter library list for quick selection and deletion.
      const renderEncounterLibrary = (initiativeMemory) => {
        const encounters = initiativeMemory.encounters ?? [];
        if (!encounters.length) {
          encounterList.innerHTML = '<li class="encounter-empty">No saved encounters yet.</li>';
          return;
        }
        encounterList.innerHTML = encounters
          .map((encounter) => {
            const isActive = encounter.id === initiativeMemory.activeEncounterId;
            const displayName = encounter.name || "Untitled Encounter";
            return `
              <li class="encounter-entry ${isActive ? "is-active" : ""}">
                <div class="encounter-entry-title">${displayName}</div>
                <div class="encounter-actions">
                  <button
                    type="button"
                    class="encounter-action"
                    data-encounter-view="${encounter.id}"
                  >
                    View
                  </button>
                  <button
                    type="button"
                    class="encounter-action"
                    data-encounter-defeat="${encounter.id}"
                  >
                    Defeat
                  </button>
                </div>
              </li>
            `;
          })
          .join("");
      };

      const updateEncounterStatusNote = (message, isWarning = false) => {
        encounterStatusNote.textContent = message;
        encounterStatusNote.style.color = isWarning ? "var(--warning)" : "var(--ink-muted)";
      };

      const loadEncounterLibrary = () => {
        const initiativeMemory = getInitiativeMemory();
        renderEncounterLibrary(initiativeMemory);
        if (initiativeMemory.activeEncounterId) {
          const active = initiativeMemory.encounters.find(
            (encounter) => encounter.id === initiativeMemory.activeEncounterId
          );
          if (active) {
            hydrateStateFromEncounter(active);
            updateEncounterNameField(active.name);
          } else {
            updateEncounterNameField("");
          }
        } else {
          updateEncounterNameField("");
        }
        renderParticipants();
        updateEncounterControls();
        updateRoundDisplay();
        updateMarkerSelects();
        updateParticipantCrVisibility();
      };

      const renderParticipants = () => {
        if (!state.participants.length) {
          participantBody.innerHTML =
            '<tr><td colspan="6" class="helper-text">Add participants to begin building the encounter.</td></tr>';
          updateEncounterSummary();
          return;
        }

        participantBody.innerHTML = state.participants
          .map((participant, index) => {
            const markers = participant.markers
              .map((marker) => {
                const durationText = marker.duration
                  ? `(${marker.duration}r)`
                  : "(end of turn)";
                return `
                  <span class="marker-chip">
                    ${marker.label} ${durationText}
                    <button type="button" aria-label="Remove marker" data-remove-marker="${marker.id}">
                      ✕
                    </button>
                  </span>
                `;
              })
              .join("");

            return `
              <tr class="participant-row ${state.encounterStarted && index === state.turnIndex ? "active" : ""}">
                <td>${participant.name}</td>
                <td>${participant.type}</td>
                <td>${participant.initiative ?? "—"}</td>
                <td>
                  ${markers || "<span class=\"helper-text\">No markers</span>"}
                </td>
                <td>
                  <div style="display: flex; flex-wrap: wrap; gap: 0.4rem;">
                    <button type="button" class="secondary" data-add-marker="${participant.id}">
                      Add Marker
                    </button>
                    <button type="button" class="ghost" data-remove-participant="${participant.id}">
                      Remove
                    </button>
                  </div>
                </td>
                <td>${formatCrXp(participant)}</td>
              </tr>
            `;
          })
          .join("");
        updateEncounterSummary();
      };

      // Render the initiative lightbox list with inputs for each participant.
      const renderInitiativeModal = () => {
        initiativeList.innerHTML = state.participants
          .map((participant) => {
            return `
              <div class="modal-item">
                <div>
                  <strong>${participant.name}</strong>
                  <div class="helper-text">${participant.type}</div>
                </div>
                <div>
                  <label class="helper-text" for="initiative-${participant.id}">Initiative</label>
                  <input
                    id="initiative-${participant.id}"
                    type="number"
                    inputmode="numeric"
                    min="-5"
                    value="${participant.initiative ?? ""}"
                  />
                </div>
              </div>
            `;
          })
          .join("");
      };

      const seedConditionPresets = () => {
        markerCondition.innerHTML = [
          '<option value="">-- Select condition --</option>',
          ...conditionPresets.map((preset) => `<option value="${preset}">${preset}</option>`),
        ].join("");
      };

      const seedChallengeRatingOptions = () => {
        seedChallengeRatings();
        updateParticipantCrVisibility();
      };

      // Initialize baseline UI.
      updateHeader("dashboard");
      // Keep encounter tools collapsed until the GM expands them.
      setEncounterPanelVisibility(false);
      seedConditionPresets();
      seedChallengeRatingOptions();
      updateEncounterControls();
      updateRoundDisplay();
      loadEncounterLibrary();
      renderNpcModule();

      // Wire module navigation events for the initiative tracker entry point.
      initiativeLaunch.addEventListener("click", openInitiativeModule);
      startSessionAction.addEventListener("click", openInitiativeModule);
      initiativeBack.addEventListener("click", closeInitiativeModule);
      npcLaunch.addEventListener("click", openNpcModule);
      npcBack.addEventListener("click", closeNpcModule);
      creatureLaunch.addEventListener("click", openCreatureModule);
      creatureBack.addEventListener("click", closeCreatureModule);
      sessionLaunch.addEventListener("click", openSessionModule);
      continuePrepAction.addEventListener("click", openSessionModule);
      sessionBack.addEventListener("click", closeSessionModule);
      // NPC wizard entry points keep the gallery as the default screen.
      npcCreate.addEventListener("click", () => openNpcWizard({ mode: "create" }));
      npcCreateInline.addEventListener("click", () => openNpcWizard({ mode: "create" }));
      npcModalClose.addEventListener("click", () => closeModal(npcModal));
      npcStepBack.addEventListener("click", () => setNpcWizardStep(npcWizardState.step - 1));
      npcStepNext.addEventListener("click", () => setNpcWizardStep(npcWizardState.step + 1));
      // Shared toggle keeps both expanded and collapsed controls in sync.
      const toggleEncounterPanel = () => {
        const isExpanded = encounterPanelToggle.getAttribute("aria-expanded") === "true";
        setEncounterPanelVisibility(!isExpanded);
      };
      encounterPanelToggle.addEventListener("click", toggleEncounterPanel);
      encounterPanelToggleCollapsed.addEventListener("click", toggleEncounterPanel);
      participantType.addEventListener("change", updateParticipantCrVisibility);

      // NPC vault form handler saves new NPCs or updates existing entries.
      npcForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const name = npcName.value.trim();
        if (!name) {
          setNpcFormNote("NPC name is required before saving.", true);
          return;
        }
        if (npcState.editingNpcId) {
          npcState.roster = npcState.roster.map((npc) =>
            npc.id === npcState.editingNpcId ? buildNpcPayload({ id: npc.id, name }) : npc
          );
          npcState.activeNpcId = npcState.editingNpcId;
        } else {
          npcState.roster = [...npcState.roster, buildNpcPayload({ name })];
          npcState.activeNpcId = npcState.roster[npcState.roster.length - 1].id;
        }
        persistNpcRoster();
        renderNpcList();
        resetNpcForm(`Saved "${name}" to the NPC roster.`);
        closeModal(npcModal);
      });

      // Session notes form handler captures manual saves and reset requests.
      sessionForm.addEventListener("submit", (event) => {
        event.preventDefault();
        saveSessionNote({ announce: true });
      });

      sessionReset.addEventListener("click", () => {
        resetSessionNote();
      });

      // Timeline buttons toggle between prep/run/review for the selected session.
      if (sessionTimelineList) {
        sessionTimelineList.addEventListener("click", (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) {
            return;
          }
          const sessionId = target.getAttribute("data-session-id");
          const view = target.getAttribute("data-session-view");
          if (!sessionId || !view) {
            return;
          }
          setActiveSession(sessionId, view);
          updateSessionStatusNote(`Viewing ${view} notes.`);
        });
      }

      // Auto-save session notes as the GM types to avoid losing live session info.
      sessionForm.querySelectorAll("input, select, textarea").forEach((input) => {
        input.addEventListener("input", queueSessionAutoSave);
        input.addEventListener("change", queueSessionAutoSave);
      });

      npcReset.addEventListener("click", () => {
        resetNpcForm();
        setNpcWizardStep(1);
      });

      // Creature library controls support roster creation, editing, and export.
      creatureNew.addEventListener("click", () => {
        resetCreatureForm("Ready to capture a new creature profile.");
        creatureState.activeCreatureId = null;
        renderCreatureList();
      });

      creatureSelectAll.addEventListener("click", () => {
        creatureState.selectedCreatureIds = new Set(creatureState.roster.map((creature) => creature.id));
        renderCreatureList();
      });

      creatureClearSelection.addEventListener("click", () => {
        creatureState.selectedCreatureIds.clear();
        renderCreatureList();
      });

      creatureExport.addEventListener("click", () => {
        const selected = creatureState.roster.filter((creature) =>
          creatureState.selectedCreatureIds.has(creature.id)
        );
        if (!selected.length) {
          creatureFormNote.textContent = "Select at least one creature before exporting cards.";
          return;
        }
        exportCreatureCards(selected);
      });

      creatureExportSelected.addEventListener("click", () => {
        const selected = creatureState.roster.filter((creature) =>
          creatureState.selectedCreatureIds.has(creature.id)
        );
        if (!selected.length) {
          creatureFormNote.textContent = "Select at least one creature before exporting cards.";
          return;
        }
        exportCreatureCards(selected);
      });

      creatureParse.addEventListener("click", () => {
        const text = creatureStatblock.value.trim();
        if (!text) {
          creatureFormNote.textContent = "Paste a statblock before parsing.";
          return;
        }
        const parsed = parseCreatureStatblock(text);
        applyCreatureParse(parsed);
        creatureFormNote.textContent = "Statblock parsed. Review and adjust before saving.";
      });

      creatureClearStatblock.addEventListener("click", () => {
        creatureStatblock.value = "";
        creatureFormNote.textContent = "Statblock field cleared.";
      });

      creatureReset.addEventListener("click", () => {
        resetCreatureForm("Form reset. Ready for a fresh creature entry.");
      });

      creatureForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const name = creatureName.value.trim();
        if (!name) {
          creatureFormNote.textContent = "Creature name is required before saving.";
          return;
        }
        if (creatureState.editingCreatureId) {
          creatureState.roster = creatureState.roster.map((creature) =>
            creature.id === creatureState.editingCreatureId
              ? buildCreaturePayload({ id: creature.id })
              : creature
          );
          creatureState.activeCreatureId = creatureState.editingCreatureId;
        } else {
          const newCreature = buildCreaturePayload();
          creatureState.roster = [...creatureState.roster, newCreature];
          creatureState.activeCreatureId = newCreature.id;
        }
        persistCreatureLibrary();
        renderCreatureList();
        resetCreatureForm(`Saved "${name}" to the creature library.`);
      });

      creatureList.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const editId = target.getAttribute("data-creature-edit");
        const deleteId = target.getAttribute("data-creature-delete");
        const duplicateId = target.getAttribute("data-creature-duplicate");

        if (editId) {
          const creature = getCreatureById(editId);
          if (creature) {
            creatureState.activeCreatureId = editId;
            creatureState.editingCreatureId = editId;
            hydrateCreatureForm(creature);
            renderCreatureList();
          }
          return;
        }

        if (duplicateId) {
          const creature = getCreatureById(duplicateId);
          if (creature) {
            const copy = {
              ...creature,
              id: generateId(),
              name: `${creature.name} (Copy)`,
              updatedAt: new Date().toISOString(),
            };
            creatureState.roster = [...creatureState.roster, copy];
            creatureState.activeCreatureId = copy.id;
            persistCreatureLibrary();
            renderCreatureList();
            creatureFormNote.textContent = `Duplicated "${creature.name}".`;
          }
          return;
        }

        if (deleteId) {
          creatureState.roster = creatureState.roster.filter((creature) => creature.id !== deleteId);
          creatureState.selectedCreatureIds.delete(deleteId);
          if (creatureState.activeCreatureId === deleteId) {
            creatureState.activeCreatureId = creatureState.roster[0]?.id ?? null;
          }
          persistCreatureLibrary();
          renderCreatureList();
        }
      });

      creatureList.addEventListener("change", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        const selectionId = target.getAttribute("data-creature-select");
        if (!selectionId) {
          return;
        }
        if (target.checked) {
          creatureState.selectedCreatureIds.add(selectionId);
        } else {
          creatureState.selectedCreatureIds.delete(selectionId);
        }
        updateCreatureSelectionCount();
      });

      // NPC roster actions support view, edit, and archive behaviors.
      npcList.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const viewId = target.getAttribute("data-npc-view");
        const editId = target.getAttribute("data-npc-edit");
        const deleteId = target.getAttribute("data-npc-delete");

        if (viewId) {
          npcState.activeNpcId = viewId;
          persistNpcRoster();
          renderNpcList();
          return;
        }
        if (editId) {
          const npc = getNpcById(editId);
          if (npc) {
            openNpcWizard({ mode: "edit", npc });
          }
          return;
        }
        if (deleteId) {
          npcState.roster = npcState.roster.filter((npc) => npc.id !== deleteId);
          if (npcState.activeNpcId === deleteId) {
            npcState.activeNpcId = npcState.roster[0]?.id ?? null;
          }
          persistNpcRoster();
          renderNpcList();
        }
      });

      // NPC status buttons update the active NPC relationship quickly.
      npcModule.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const status = target.getAttribute("data-npc-status");
        if (!status || !npcState.activeNpcId) {
          return;
        }
        npcState.roster = npcState.roster.map((npc) =>
          npc.id === npcState.activeNpcId ? { ...npc, relationship: status } : npc
        );
        persistNpcRoster();
        renderNpcList();
      });

      participantForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const name = participantName.value.trim();
        const type = participantType.value;
        if (!name) {
          return;
        }
        const challengeRating = isMonsterType(type) ? participantCr.value : null;
        state.participants.push({
          id: generateId(),
          name,
          type,
          challengeRating,
          initiative: null,
          markers: [],
        });
        state.rewardsGranted = false;
        participantName.value = "";
        participantCr.value = challengeRatings[0]?.value ?? "";
        renderParticipants();
        updateEncounterControls();
        updateMarkerSelects();
        persistActiveEncounter();
      });

      startEncounterButton.addEventListener("click", () => {
        if (!state.participants.length) {
          return;
        }
        renderInitiativeModal();
        openModal(initiativeModal);
      });

      rewardEncounterButton.addEventListener("click", () => {
        if (!state.encounterStarted) {
          return;
        }
        state.rewardsGranted = true;
        updateEncounterControls();
        updateEncounterStatusNote("Rewards marked as distributed.");
        persistActiveEncounter();
      });

      initiativeCancel.addEventListener("click", () => {
        closeModal(initiativeModal);
      });

      initiativeConfirm.addEventListener("click", () => {
        state.participants = state.participants.map((participant) => {
          const input = document.getElementById(`initiative-${participant.id}`);
          const value = Number.parseInt(input.value, 10);
          return {
            ...participant,
            initiative: Number.isNaN(value) ? 0 : value,
          };
        });
        state.participants.sort((a, b) => {
          if (b.initiative !== a.initiative) {
            return b.initiative - a.initiative;
          }
          return a.name.localeCompare(b.name);
        });
        state.encounterStarted = true;
        state.rewardsGranted = false;
        state.round = 1;
        state.turnIndex = 0;
        closeModal(initiativeModal);
        renderParticipants();
        updateEncounterControls();
        updateRoundDisplay();
        updateMarkerSelects();
        persistActiveEncounter();
      });

      participantBody.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const removeId = target.getAttribute("data-remove-participant");
        const addMarkerId = target.getAttribute("data-add-marker");
        const removeMarkerId = target.getAttribute("data-remove-marker");

        if (removeId) {
          state.participants = state.participants.filter((participant) => participant.id !== removeId);
          if (state.turnIndex >= state.participants.length) {
            state.turnIndex = Math.max(0, state.participants.length - 1);
          }
          state.rewardsGranted = false;
          renderParticipants();
          updateEncounterControls();
          updateRoundDisplay();
          updateMarkerSelects();
          persistActiveEncounter();
          return;
        }

        if (addMarkerId) {
          // Default marker timing should follow the active turn, not the target, for GM speed.
          const currentParticipant = getCurrentParticipant();
          const defaultStartId = currentParticipant ? currentParticipant.id : addMarkerId;
          state.editingTargetId = addMarkerId;
          updateMarkerSelects();
          markerTarget.value = addMarkerId;
          markerStart.value = defaultStartId;
          markerCondition.value = "";
          markerLabel.value = "";
          markerDuration.value = "";
          openModal(markerModal);
          return;
        }

        if (removeMarkerId) {
          state.participants = state.participants.map((participant) => ({
            ...participant,
            markers: participant.markers.filter((marker) => marker.id !== removeMarkerId),
          }));
          renderParticipants();
          persistActiveEncounter();
        }
      });

      markerCancel.addEventListener("click", () => {
        closeModal(markerModal);
      });

      markerForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const targetId = markerTarget.value;
        const startId = markerStart.value;
        const durationValue = markerDuration.value ? Number.parseInt(markerDuration.value, 10) : null;
        const conditionValue = markerCondition.value.trim();
        const customLabelValue = markerLabel.value.trim();
        const label = customLabelValue || conditionValue;
        if (!targetId || !startId || !label) {
          return;
        }

        const startTurnNumber = getNextTurnNumberForParticipant(startId);
        const total = state.participants.length || 1;
        const durationRounds = durationValue && durationValue > 0 ? durationValue : null;
        const endTurnNumber = durationRounds ? startTurnNumber + durationRounds * total : null;

        const marker = {
          id: generateId(),
          label,
          duration: durationRounds,
          startParticipantId: startId,
          startTurnNumber,
          endTurnNumber,
        };

        state.participants = state.participants.map((participant) => {
          if (participant.id !== targetId) {
            return participant;
          }
          return {
            ...participant,
            markers: [...participant.markers, marker],
          };
        });

        closeModal(markerModal);
        renderParticipants();
        persistActiveEncounter();
      });

      const queuePrompt = (participant, marker, reason) => {
        state.promptQueue.push({ participant, marker, reason });
      };

      const processPromptQueue = () => {
        if (!state.promptQueue.length) {
          closeModal(expiryModal);
          if (state.pendingAdvance) {
            completeTurnAdvance();
          }
          return;
        }
        const nextPrompt = state.promptQueue[0];
        const reasonText = nextPrompt.reason === "duration"
          ? "Duration complete"
          : "End of turn reminder";
        expiryMessage.textContent = `${reasonText}: Remove "${nextPrompt.marker.label}" from ${nextPrompt.participant.name}?`;
        openModal(expiryModal);
      };

      expiryKeep.addEventListener("click", () => {
        state.promptQueue.shift();
        processPromptQueue();
      });

      expiryRemove.addEventListener("click", () => {
        const { marker } = state.promptQueue.shift();
        state.participants = state.participants.map((participant) => ({
          ...participant,
          markers: participant.markers.filter((existing) => existing.id !== marker.id),
        }));
        renderParticipants();
        processPromptQueue();
        persistActiveEncounter();
      });

      const checkForExpiryPrompts = () => {
        const current = getCurrentParticipant();
        if (!current) {
          return;
        }
        const currentTurnNumber = getCurrentTurnNumber();
        current.markers.forEach((marker) => {
          if (!marker.duration) {
            queuePrompt(current, marker, "end-turn");
          }
        });
        state.participants.forEach((participant) => {
          participant.markers.forEach((marker) => {
            if (
              marker.duration &&
              marker.endTurnNumber !== null &&
              marker.startParticipantId === current.id &&
              marker.endTurnNumber === currentTurnNumber
            ) {
              queuePrompt(participant, marker, "duration");
            }
          });
        });
      };

      const completeTurnAdvance = () => {
        state.pendingAdvance = false;
        if (!state.participants.length) {
          return;
        }
        if (state.turnIndex < state.participants.length - 1) {
          state.turnIndex += 1;
        } else {
          state.turnIndex = 0;
          state.round += 1;
        }
        renderParticipants();
        updateRoundDisplay();
        persistActiveEncounter();
      };

      const completeTurnRewind = () => {
        if (!state.participants.length) {
          return;
        }
        if (state.turnIndex > 0) {
          state.turnIndex -= 1;
        } else if (state.round > 1) {
          state.round -= 1;
          state.turnIndex = state.participants.length - 1;
        }
        renderParticipants();
        updateRoundDisplay();
        persistActiveEncounter();
      };

      nextTurnButton.addEventListener("click", () => {
        if (!state.encounterStarted) {
          return;
        }
        state.promptQueue = [];
        checkForExpiryPrompts();
        if (state.promptQueue.length) {
          state.pendingAdvance = true;
          processPromptQueue();
          return;
        }
        completeTurnAdvance();
      });

      previousTurnButton.addEventListener("click", () => {
        if (!state.encounterStarted) {
          return;
        }
        completeTurnRewind();
      });

      // Encounter management handlers wire local storage for persistent switching.
      const loadEncounterById = (selectedId) => {
        if (!selectedId) {
          return;
        }
        const initiativeMemory = updateInitiativeMemory((memory) => ({
          ...memory,
          activeEncounterId: selectedId,
        }));
        const selectedEncounter = initiativeMemory.encounters.find(
          (encounter) => encounter.id === selectedId
        );
        if (!selectedEncounter) {
          return;
        }
        hydrateStateFromEncounter(selectedEncounter);
        updateEncounterNameField(selectedEncounter.name);
        renderEncounterLibrary(initiativeMemory);
        updateEncounterControls();
        updateRoundDisplay();
        renderParticipants();
        updateMarkerSelects();
        updateEncounterStatusNote(`Loaded "${selectedEncounter.name}".`);
      };

      const deleteEncounterById = (encounterId) => {
        const initiativeMemory = updateInitiativeMemory((memory) => {
          const encounters = memory.encounters.filter((encounter) => encounter.id !== encounterId);
          const nextActiveId = encounters[0]?.id ?? null;
          return { ...memory, encounters, activeEncounterId: nextActiveId };
        });
        const nextActive = initiativeMemory.encounters.find(
          (encounter) => encounter.id === initiativeMemory.activeEncounterId
        );
        if (nextActive) {
          hydrateStateFromEncounter(nextActive);
          updateEncounterNameField(nextActive.name);
        } else {
          hydrateStateFromEncounter({
            id: null,
            name: "",
            participants: [],
            encounterStarted: false,
            rewardsGranted: false,
            round: 1,
            turnIndex: 0,
          });
          updateEncounterNameField("");
        }
        renderEncounterLibrary(initiativeMemory);
        updateEncounterControls();
        updateRoundDisplay();
        renderParticipants();
        updateMarkerSelects();
        updateEncounterStatusNote("Encounter removed from local memory.");
      };

      createEncounterButton.addEventListener("click", () => {
        const name = encounterNameInput.value.trim();
        if (!name) {
          updateEncounterStatusNote("Add a name before creating a new encounter.", true);
          return;
        }
        const newEncounter = {
          id: generateId(),
          name,
          participants: [],
          encounterStarted: false,
          rewardsGranted: false,
          round: 1,
          turnIndex: 0,
          updatedAt: new Date().toISOString(),
        };
        const initiativeMemory = updateInitiativeMemory((memory) => ({
          ...memory,
          encounters: [...memory.encounters, newEncounter],
          activeEncounterId: newEncounter.id,
        }));
        hydrateStateFromEncounter(newEncounter);
        updateEncounterNameField(newEncounter.name);
        renderEncounterLibrary(initiativeMemory);
        updateEncounterControls();
        updateRoundDisplay();
        renderParticipants();
        updateMarkerSelects();
        updateEncounterStatusNote(`Created and opened "${newEncounter.name}".`);
      });

      saveEncounterButton.addEventListener("click", () => {
        if (!state.activeEncounterId) {
          updateEncounterStatusNote("Create or select an encounter before saving.", true);
          return;
        }
        const name = encounterNameInput.value.trim();
        if (!name) {
          updateEncounterStatusNote("Add a name before saving the encounter.", true);
          return;
        }
        const initiativeMemory = updateInitiativeMemory((memory) => {
          const encounters = memory.encounters.map((encounter) =>
            encounter.id === state.activeEncounterId
              ? { ...encounter, ...buildEncounterPayload({ name }) }
              : encounter
          );
          return { ...memory, encounters };
        });
        renderEncounterLibrary(initiativeMemory);
        updateEncounterStatusNote("Encounter saved to local memory.");
      });

      encounterList.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const viewId = target.getAttribute("data-encounter-view");
        if (viewId) {
          loadEncounterById(viewId);
          return;
        }
        const defeatId = target.getAttribute("data-encounter-defeat");
        if (defeatId) {
          deleteEncounterById(defeatId);
        }
      });
    </script>
  </body>
</html>
